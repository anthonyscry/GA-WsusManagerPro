---
phase: 14-client-management-core
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - src/WsusManager.App/ViewModels/MainViewModel.cs
  - src/WsusManager.App/Views/MainWindow.xaml
  - src/WsusManager.App/Program.cs
autonomous: true
requirements: [CLI-01, CLI-02, CLI-04, CLI-05, CLI-06, CLI-07]

must_haves:
  truths:
    - "Admin sees a 'Client Tools' panel with a hostname input field and 5 action buttons"
    - "Admin enters a hostname, clicks Cancel Stuck Jobs, and sees step-by-step results in the log panel"
    - "Admin clicks Force Check-In and sees gpupdate/resetauthorization/detectnow/reportnow progress"
    - "Admin clicks Test Connectivity and sees port 8530/8531 pass/fail results"
    - "Admin clicks Run Diagnostics and sees WSUS settings, service status, last check-in, reboot state"
    - "Admin enters an error code in the error code lookup field and sees description and recommended fix"
    - "All client buttons are disabled when no hostname is entered (except error code lookup)"
    - "All client buttons are disabled during an active operation (CanExecute pattern)"
    - "IClientService and WinRmExecutor are registered in DI container"
  artifacts:
    - path: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      provides: "Client management commands and properties"
      contains: "RunClientCancelStuckJobsCommand"
    - path: "src/WsusManager.App/Views/MainWindow.xaml"
      provides: "Client Tools panel with hostname input and action buttons"
      contains: "ClientToolsPanel"
    - path: "src/WsusManager.App/Program.cs"
      provides: "DI registration for IClientService and WinRmExecutor"
      contains: "IClientService"
  key_links:
    - from: "MainViewModel"
      to: "IClientService"
      via: "constructor injection and command methods"
      pattern: "_clientService.CancelStuckJobsAsync"
    - from: "MainWindow.xaml"
      to: "MainViewModel"
      via: "data binding"
      pattern: "Command=\"{Binding RunClientCancelStuckJobsCommand}\""
    - from: "Program.cs"
      to: "ClientService"
      via: "DI registration"
      pattern: "AddSingleton<IClientService, ClientService>"
---

<objective>
Wire client management into the GUI — add the Client Tools panel, ViewModel commands, and DI registration.

Purpose: Makes all client management operations accessible from the GUI. This is the final plan that delivers the complete Phase 14 feature set.

Output: Updated MainViewModel.cs with client commands, new Client Tools panel in MainWindow.xaml, DI wiring in Program.cs.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-client-management-core/14-01-SUMMARY.md
@.planning/phases/14-client-management-core/14-02-SUMMARY.md
@src/WsusManager.App/ViewModels/MainViewModel.cs
@src/WsusManager.App/Views/MainWindow.xaml
@src/WsusManager.App/Program.cs
@src/WsusManager.App/Themes/DarkTheme.xaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add client management commands and properties to MainViewModel</name>
  <files>
    src/WsusManager.App/ViewModels/MainViewModel.cs
    src/WsusManager.App/Program.cs
  </files>
  <action>
**Program.cs — DI registration:**
Add after the Phase 6 registrations block:
```csharp
// Phase 14: Client Management
builder.Services.AddSingleton<WinRmExecutor>();
builder.Services.AddSingleton<IClientService, ClientService>();
```
Add required using: `using WsusManager.Core.Services;` (already present for other services).

**MainViewModel.cs — Constructor:**
Add `IClientService _clientService` field and constructor parameter. Add it after `_gpoDeploymentService`.

**MainViewModel.cs — New section after INSTALLATION & SCHEDULING:**

Add a new section header:
```
// ═══════════════════════════════════════════════════════════════
// CLIENT MANAGEMENT (Phase 14)
// ═══════════════════════════════════════════════════════════════
```

**Properties:**
```csharp
[ObservableProperty]
private string _clientHostname = string.Empty;

[ObservableProperty]
private string _errorCodeInput = string.Empty;

[ObservableProperty]
private string _errorCodeResult = string.Empty;
```

**CanExecute helpers:**
```csharp
private bool CanExecuteClientOperation() =>
    !IsOperationRunning && !string.IsNullOrWhiteSpace(ClientHostname);
```

**Commands (all use [RelayCommand] with CanExecute):**

1. `RunClientCancelStuckJobs` — CanExecute: `CanExecuteClientOperation`. Navigate to "ClientTools" panel. Call `RunOperationAsync("Cancel Stuck Jobs", ...)` delegating to `_clientService.CancelStuckJobsAsync(ClientHostname.Trim(), progress, ct)`.

2. `RunClientForceCheckIn` — Same pattern, calls `_clientService.ForceCheckInAsync(...)`.

3. `RunClientTestConnectivity` — Same pattern, calls `_clientService.TestConnectivityAsync(ClientHostname.Trim(), $"http://{_settings.SqlInstance.Split('\\')[0]}:8530", progress, ct)`. After success, report each field of ConnectivityTestResult.

4. `RunClientDiagnostics` — Same pattern, calls `_clientService.RunDiagnosticsAsync(...)`. After success, report each field of ClientDiagnosticResult in a formatted block.

5. `LookupErrorCode` — No CanExecute restriction (local, no remote call). Not async. Call `_clientService.LookupErrorCode(ErrorCodeInput.Trim())`. Set `ErrorCodeResult` to formatted string: "Code: {hex}\nDescription: {desc}\n\nRecommended Fix:\n{fix}" or "Error code not recognized." if not found. Do NOT go through RunOperationAsync — this is instant.

**Navigation:**
Add `"ClientTools"` case to Navigate() method:
```csharp
"ClientTools" => "Client Tools",
```

Add visibility property:
```csharp
public Visibility IsClientToolsPanelVisible =>
    CurrentPanel == "ClientTools" ? Visibility.Visible : Visibility.Collapsed;
```

Update Navigate() to call `OnPropertyChanged(nameof(IsClientToolsPanelVisible))`.

Update `IsOperationPanelVisible` to exclude "ClientTools" (add it to the condition alongside Dashboard/Diagnostics/Database).

**NotifyCommandCanExecuteChanged:**
Add all new client commands to the notification list:
```csharp
// Phase 14: Client Management
RunClientCancelStuckJobsCommand.NotifyCanExecuteChanged();
RunClientForceCheckInCommand.NotifyCanExecuteChanged();
RunClientTestConnectivityCommand.NotifyCanExecuteChanged();
RunClientDiagnosticsCommand.NotifyCanExecuteChanged();
```

Also override `OnClientHostnameChanged` partial method to notify CanExecute when hostname changes:
```csharp
partial void OnClientHostnameChanged(string value)
{
    RunClientCancelStuckJobsCommand.NotifyCanExecuteChanged();
    RunClientForceCheckInCommand.NotifyCanExecuteChanged();
    RunClientTestConnectivityCommand.NotifyCanExecuteChanged();
    RunClientDiagnosticsCommand.NotifyCanExecuteChanged();
}
```

**Important patterns from CLAUDE.md:**
- Dialog before panel switch (but no dialog needed here — just Navigate)
- All operations go through RunOperationAsync (except LookupErrorCode which is instant)
- CanExecute disables buttons during operations (existing pattern handles this)
  </action>
  <verify>
Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj`
Verify: Compiles without errors. All 5 client commands are generated.
  </verify>
  <done>MainViewModel has 5 client management commands with proper CanExecute. ClientHostname property drives button enablement. Error code lookup is instant (no RunOperationAsync). DI container registers IClientService and WinRmExecutor. Navigation includes ClientTools panel.</done>
</task>

<task type="auto">
  <name>Task 2: Add Client Tools panel to MainWindow.xaml</name>
  <files>
    src/WsusManager.App/Views/MainWindow.xaml
  </files>
  <action>
Add a new "Client Tools" panel in MainWindow.xaml, visible when `IsClientToolsPanelVisible` is bound.

**Sidebar — add CLIENT TOOLS category** after the DIAGNOSTICS category (before DATABASE):
```xml
<!-- CLIENT TOOLS Category -->
<TextBlock DockPanel.Dock="Top" Text="CLIENT TOOLS" Style="{StaticResource CategoryLabel}"/>
<Button DockPanel.Dock="Top" Content="Client Tools"
        x:Name="BtnClientTools"
        Command="{Binding NavigateCommand}" CommandParameter="ClientTools">
    <Button.Style>
        <Style TargetType="Button" BasedOn="{StaticResource NavBtn}">
            <Style.Triggers>
                <DataTrigger Binding="{Binding CurrentPanel}" Value="ClientTools">
                    <Setter Property="Background" Value="#21262D"/>
                    <Setter Property="BorderBrush" Value="#58A6FF"/>
                    <Setter Property="BorderThickness" Value="3,0,0,0"/>
                    <Setter Property="Foreground" Value="#E6EDF3"/>
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </Button.Style>
</Button>
```

**Client Tools Panel** — add inside the Grid containing all content panels (alongside DashboardPanel, DiagnosticsPanel, DatabasePanel, OperationPanel). Place before the OperationPanel:

```xml
<!-- Client Tools Panel -->
<Border x:Name="ClientToolsPanel"
        Visibility="{Binding IsClientToolsPanelVisible}">
    <ScrollViewer VerticalScrollBarVisibility="Auto" Padding="16">
        <StackPanel>

            <!-- Target Host -->
            <Border Background="{StaticResource BgCard}" CornerRadius="6"
                    Padding="16" Margin="0,0,0,12">
                <StackPanel>
                    <TextBlock Text="Target Host" FontSize="14" FontWeight="SemiBold"
                               Foreground="{StaticResource Text1}" Margin="0,0,0,8"/>
                    <TextBlock Text="Enter the hostname of the client machine to manage. Operations use WinRM (Windows Remote Management)."
                               Foreground="{StaticResource Text2}" FontSize="12"
                               TextWrapping="Wrap" Margin="0,0,0,12"/>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="80"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="Hostname:"
                                   Foreground="{StaticResource Text2}" FontSize="13"
                                   VerticalAlignment="Center"/>
                        <TextBox Grid.Column="1"
                                 Text="{Binding ClientHostname, UpdateSourceTrigger=PropertyChanged}"
                                 Background="{StaticResource BgInput}"
                                 Foreground="{StaticResource Text1}"
                                 BorderBrush="{StaticResource Border}"
                                 Padding="8,6" FontSize="13"/>
                    </Grid>
                </StackPanel>
            </Border>

            <!-- Remote Operations -->
            <Border Background="{StaticResource BgCard}" CornerRadius="6"
                    Padding="16" Margin="0,0,0,12">
                <StackPanel>
                    <TextBlock Text="Remote Operations" FontSize="14" FontWeight="SemiBold"
                               Foreground="{StaticResource Text1}" Margin="0,0,0,12"/>
                    <WrapPanel>
                        <Button Content="Cancel Stuck Jobs" Style="{StaticResource BtnSec}"
                                Padding="16,8" Margin="0,0,8,8"
                                Command="{Binding RunClientCancelStuckJobsCommand}"
                                ToolTip="Stop WU services, clear cache, restart — fixes stuck update jobs"/>
                        <Button Content="Force Check-In" Style="{StaticResource BtnSec}"
                                Padding="16,8" Margin="0,0,8,8"
                                Command="{Binding RunClientForceCheckInCommand}"
                                ToolTip="Run gpupdate, resetauthorization, detectnow, reportnow"/>
                        <Button Content="Test Connectivity" Style="{StaticResource BtnSec}"
                                Padding="16,8" Margin="0,0,8,8"
                                Command="{Binding RunClientTestConnectivityCommand}"
                                ToolTip="Test TCP connection from client to WSUS server on ports 8530/8531"/>
                        <Button Content="Run Diagnostics" Style="{StaticResource BtnGreen}"
                                Padding="16,8" Margin="0,0,8,8"
                                Command="{Binding RunClientDiagnosticsCommand}"
                                ToolTip="Gather WSUS settings, service status, last check-in, reboot state"/>
                    </WrapPanel>
                </StackPanel>
            </Border>

            <!-- Error Code Lookup -->
            <Border Background="{StaticResource BgCard}" CornerRadius="6"
                    Padding="16">
                <StackPanel>
                    <TextBlock Text="Error Code Lookup" FontSize="14" FontWeight="SemiBold"
                               Foreground="{StaticResource Text1}" Margin="0,0,0,8"/>
                    <TextBlock Text="Enter a WSUS or Windows Update error code (e.g., 0x80072EE2) to see its description and recommended fix."
                               Foreground="{StaticResource Text2}" FontSize="12"
                               TextWrapping="Wrap" Margin="0,0,0,12"/>
                    <Grid Margin="0,0,0,8">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="90"/>
                            <ColumnDefinition Width="200"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="Error Code:"
                                   Foreground="{StaticResource Text2}" FontSize="13"
                                   VerticalAlignment="Center"/>
                        <TextBox Grid.Column="1"
                                 Text="{Binding ErrorCodeInput, UpdateSourceTrigger=PropertyChanged}"
                                 Background="{StaticResource BgInput}"
                                 Foreground="{StaticResource Text1}"
                                 BorderBrush="{StaticResource Border}"
                                 Padding="8,6" FontSize="13"/>
                        <Button Grid.Column="2" Content="Lookup" Style="{StaticResource BtnSec}"
                                Padding="16,6" Margin="8,0,0,0"
                                Command="{Binding LookupErrorCodeCommand}"/>
                    </Grid>
                    <TextBox Text="{Binding ErrorCodeResult, Mode=OneWay}"
                             Background="{StaticResource BgDark}"
                             Foreground="{StaticResource Text1}"
                             BorderThickness="0"
                             FontFamily="Consolas" FontSize="12"
                             IsReadOnly="True" TextWrapping="Wrap"
                             Padding="8" MinHeight="60"
                             Visibility="{Binding ErrorCodeResult, Converter={x:Static StringToVisibilityConverter.Instance}, FallbackValue=Collapsed}"/>
                </StackPanel>
            </Border>

        </StackPanel>
    </ScrollViewer>
</Border>
```

**Note on ErrorCodeResult visibility:** Since we can't easily use a converter without adding one, simplify by always showing the TextBox but setting MinHeight to 0 when empty. Actually, the simplest approach: just always show the result TextBox. When ErrorCodeResult is empty, it shows as an empty box — this is acceptable. Remove the Visibility binding and keep it simple. OR, even better: only show the result area when ErrorCodeResult has content. To do this without a custom converter, use a DataTrigger on the Border or TextBox. The cleanest approach for this codebase (no converters exist yet): Just always show the TextBox. It starts empty and fills on lookup. This is fine UX.

So replace the Visibility binding with just always-visible, or wrap it in a style with DataTrigger. Simplest: always show it.

**Full build verification is critical** — XAML binding errors are silent at compile time but fail at runtime.
  </action>
  <verify>
Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj`
Full solution: `dotnet build src/WsusManager.sln`
Test: `dotnet test src/WsusManager.Tests/ --verbosity normal`
Verify: Full solution compiles. All existing tests plus new ClientServiceTests pass. Client Tools panel is defined in XAML with correct bindings.
  </verify>
  <done>Client Tools panel in MainWindow.xaml has hostname input, 4 remote operation buttons, and error code lookup. Sidebar has CLIENT TOOLS nav entry with active highlighting. All buttons bind to ViewModel commands with proper CanExecute. Full solution builds and all tests pass.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/WsusManager.sln` — full solution compiles without errors
2. `dotnet test src/WsusManager.Tests/ --verbosity normal` — all tests pass (existing + new)
3. Client Tools panel appears in sidebar navigation
4. Hostname input field enables/disables remote operation buttons
5. Error code lookup works without hostname (local operation)
6. All commands are registered in NotifyCommandCanExecuteChanged
7. DI container has IClientService and WinRmExecutor registered
</verification>

<success_criteria>
Complete Phase 14 feature set is accessible from the GUI. Admin can navigate to Client Tools, enter a hostname, and execute all 5 client management operations. Error code lookup works independently of hostname. All existing tests continue to pass alongside new ClientService tests.
</success_criteria>

<output>
After completion, create `.planning/phases/14-client-management-core/14-03-SUMMARY.md`
</output>
