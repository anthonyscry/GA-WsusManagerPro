---
phase: 14-client-management-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/WsusManager.Core/Services/Interfaces/IClientService.cs
  - src/WsusManager.Core/Services/WinRmExecutor.cs
  - src/WsusManager.Core/Models/ClientDiagnosticResult.cs
  - src/WsusManager.Core/Models/WsusErrorCodes.cs
autonomous: true
requirements: [CLI-06, CLI-07]

must_haves:
  truths:
    - "IClientService interface defines all 5 client operations with consistent signatures"
    - "WinRmExecutor can run PowerShell commands on a remote host via Invoke-Command"
    - "WsusErrorCodes dictionary maps at least 20 common WSUS error codes to descriptions and fixes"
    - "ClientDiagnosticResult model captures all fields needed for remote diagnostics display"
  artifacts:
    - path: "src/WsusManager.Core/Services/Interfaces/IClientService.cs"
      provides: "Interface for all client management operations"
      exports: ["IClientService"]
    - path: "src/WsusManager.Core/Services/WinRmExecutor.cs"
      provides: "WinRM remote command execution via powershell.exe Invoke-Command"
      exports: ["WinRmExecutor"]
    - path: "src/WsusManager.Core/Models/ClientDiagnosticResult.cs"
      provides: "Models for client diagnostic data and connectivity test results"
      exports: ["ClientDiagnosticResult", "ConnectivityTestResult"]
    - path: "src/WsusManager.Core/Models/WsusErrorCodes.cs"
      provides: "Static dictionary of WSUS error codes with descriptions and fixes"
      exports: ["WsusErrorCodes"]
  key_links:
    - from: "IClientService"
      to: "WinRmExecutor"
      via: "service implementation will use executor for remote commands"
      pattern: "WinRmExecutor"
    - from: "WinRmExecutor"
      to: "IProcessRunner"
      via: "delegates to existing process runner for powershell.exe execution"
      pattern: "_processRunner.RunAsync"
---

<objective>
Create the interface, models, and infrastructure for client management operations.

Purpose: Establishes the contract (IClientService), the WinRM execution helper, error code dictionary, and result models that Plan 02 will implement and Plan 03 will wire into the GUI.

Output: 4 new files in WsusManager.Core — interface, executor, models, error codes.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/WsusManager.Core/Services/Interfaces/IHealthService.cs
@src/WsusManager.Core/Models/OperationResult.cs
@src/WsusManager.Core/Infrastructure/IProcessRunner.cs
@Scripts/Invoke-WsusClientCheckIn.ps1
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IClientService interface, result models, and error code dictionary</name>
  <files>
    src/WsusManager.Core/Services/Interfaces/IClientService.cs
    src/WsusManager.Core/Models/ClientDiagnosticResult.cs
    src/WsusManager.Core/Models/WsusErrorCodes.cs
  </files>
  <action>
Create three files:

**IClientService.cs** — Interface with 5 methods matching the phase requirements. Follow the IHealthService pattern (return OperationResult, accept IProgress + CancellationToken):

```csharp
Task<OperationResult> CancelStuckJobsAsync(string hostname, IProgress<string> progress, CancellationToken ct);
Task<OperationResult> ForceCheckInAsync(string hostname, IProgress<string> progress, CancellationToken ct);
Task<OperationResult<ConnectivityTestResult>> TestConnectivityAsync(string hostname, string wsusServerUrl, IProgress<string> progress, CancellationToken ct);
Task<OperationResult<ClientDiagnosticResult>> RunDiagnosticsAsync(string hostname, IProgress<string> progress, CancellationToken ct);
OperationResult<WsusErrorInfo> LookupErrorCode(string errorCode);
```

Note: `LookupErrorCode` is synchronous — no remote call needed (CLI-06 is local lookup).

**ClientDiagnosticResult.cs** — Record with properties from the SOP diagnostic commands:
- `WsusServerUrl` (string) — configured WSUS server from registry
- `WsusStatusServerUrl` (string)
- `UseWUServer` (bool)
- `ServiceStatuses` (Dictionary<string, string>) — wuauserv, bits, etc.
- `LastCheckInTime` (DateTime?)
- `PendingRebootRequired` (bool)
- `WindowsUpdateAgentVersion` (string)

Also define `ConnectivityTestResult` record:
- `Port8530Reachable` (bool)
- `Port8531Reachable` (bool)
- `LatencyMs` (int)

And `WsusErrorInfo` record:
- `Code` (string)
- `HexCode` (string)
- `Description` (string)
- `RecommendedFix` (string)

**WsusErrorCodes.cs** — Static class with `Dictionary<string, WsusErrorInfo>` containing at minimum these common WSUS error codes:
- 0x80244010 (exceeded max server round trips)
- 0x8024402C (proxy list could not be found)
- 0x80244017 (server changed during session)
- 0x8024401C (proxy authentication required)
- 0x80070005 (access denied)
- 0x80072EE2 (timeout / cannot connect to server)
- 0x80072EFD (cannot connect to server)
- 0x80072F8F (SSL/TLS certificate error)
- 0x8024D009 (Windows Update agent needs update)
- 0x80240022 (all updates already installed)
- 0x8024A000 (automatic updates service not running)
- 0x8024000B (operation cancelled)
- 0x80244019 (metadata exceeded max size)
- 0x80070002 (file not found / SoftwareDistribution corruption)
- 0x800B0109 (certificate chain processing error)
- 0x8024401A (WSUS server returned error)
- 0x80240016 (reboot required before install)
- 0x80244007 (unexpected HTTP status)
- 0x8024D007 (Windows Update agent could not be updated)
- 0x80248007 (update metadata download failed)

The dictionary should be keyed by hex code (case-insensitive). Include a `Lookup(string input)` method that handles both hex codes (0x80244010) and decimal error codes, returning null if not found.
  </action>
  <verify>
Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj`
Verify: All 3 files compile without errors. IClientService has 5 methods. WsusErrorCodes has 20+ entries.
  </verify>
  <done>IClientService interface defines all 5 operations. ClientDiagnosticResult captures remote host info. WsusErrorCodes has 20+ error entries with descriptions and fixes. All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Create WinRmExecutor for remote PowerShell command execution</name>
  <files>
    src/WsusManager.Core/Services/WinRmExecutor.cs
  </files>
  <action>
Create `WinRmExecutor` class that wraps `IProcessRunner` to execute PowerShell commands on remote hosts via `Invoke-Command`.

Constructor takes `IProcessRunner` and `ILogService`.

**Key method:**
```csharp
public async Task<ProcessResult> ExecuteRemoteAsync(
    string hostname,
    string scriptBlock,
    IProgress<string>? progress = null,
    CancellationToken ct = default)
```

Implementation:
1. Build the command: `powershell.exe` with arguments: `-NoProfile -NonInteractive -Command "Invoke-Command -ComputerName '{hostname}' -ScriptBlock { {scriptBlock} } -ErrorAction Stop"`
2. Delegate to `_processRunner.RunAsync(...)` with the constructed command
3. Log the command at Debug level (mask the scriptBlock for brevity)
4. Return the ProcessResult directly

**Also add a connectivity check method:**
```csharp
public async Task<bool> TestWinRmAsync(string hostname, CancellationToken ct = default)
```
Implementation: Run `powershell.exe -NoProfile -NonInteractive -Command "Test-WSMan -ComputerName '{hostname}' -ErrorAction Stop"` and return true if exit code is 0.

**Important design decisions per STATE.md:**
- WinRM availability is NOT guaranteed on target hosts
- Each remote operation should gracefully handle WinRM failure with a clear error message like: "[FAIL] Cannot connect to {hostname} via WinRM. Ensure WinRM is enabled on the target (winrm quickconfig) or use the Script Generator in Phase 15."
- Do NOT throw on WinRM failure — return a failed ProcessResult
- Hostname parameter should be validated (not null/empty, no injection characters — alphanumeric, hyphens, dots only)
  </action>
  <verify>
Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj`
Verify: WinRmExecutor compiles. Has ExecuteRemoteAsync and TestWinRmAsync methods.
  </verify>
  <done>WinRmExecutor wraps IProcessRunner for remote command execution via Invoke-Command. Hostname validation prevents injection. WinRM failures return clear error messages referencing the Script Generator fallback.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/WsusManager.Core/WsusManager.Core.csproj` — compiles without errors
2. IClientService has exactly 5 methods: CancelStuckJobsAsync, ForceCheckInAsync, TestConnectivityAsync, RunDiagnosticsAsync, LookupErrorCode
3. WsusErrorCodes contains 20+ entries with hex code, description, and fix
4. WinRmExecutor validates hostname and delegates to IProcessRunner
5. All models are records with appropriate properties
</verification>

<success_criteria>
All 4 new files compile cleanly. The interface, models, error codes, and WinRM executor provide the complete foundation for Plan 02 (service implementation) and Plan 03 (GUI integration).
</success_criteria>

<output>
After completion, create `.planning/phases/14-client-management-core/14-01-SUMMARY.md`
</output>
