---
phase: 25-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/WsusManager.App/Program.cs
  - src/WsusManager.App/ViewModels/MainViewModel.cs
  - src/WsusManager.Core/Services/DashboardService.cs
  - src/WsusManager.Core/Services/SqlService.cs
autonomous: true
requirements: [PERF-08]

must_haves:
  truths:
    - "Application cold startup completes within 1.5 seconds (30% improvement over v4.4 ~2s baseline)"
    - "UI shell renders before dashboard data loads"
    - "Settings file load doesn't block UI thread"
    - "First dashboard refresh starts after UI is visible"
  artifacts:
    - path: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      provides: "Parallelized initialization using Task.WhenAll"
      contains: "InitializeAsync"
      min_lines: 30
    - path: "src/WsusManager.App/Program.cs"
      provides: "Deferred theme resource preloading to after window creation"
      contains: "CreateHost"
    - path: "src/WsusManager.Core/Services/DashboardService.cs"
      provides: "Cached server status with TTL to avoid repeated queries during startup"
      contains: "CollectAsync"
  key_links:
    - from: "src/WsusManager.App/Program.cs"
      to: "src/WsusManager.App/ViewModels/MainViewModel.InitializeAsync"
      via: "MainWindow.Loaded event handler triggers async init"
      pattern: "window\.Loaded.*async.*Initialize"
    - from: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      to: "src/WsusManager.Core/Services/DashboardService.cs"
      via: "RefreshDashboard calls CollectAsync for status data"
      pattern: "await.*RefreshDashboard|RefreshDashboard.*await"
---

<objective>
Parallelize application initialization to reduce cold startup time by 30%. Defer non-critical data loading until after UI renders, so users see the application window immediately rather than waiting for all data to load.

Purpose: Faster perceived startup performance improves user experience, especially when launching frequently during WSUS administration sessions.

Output: Startup time reduced from ~2000ms to <1500ms, with UI shell rendering before dashboard data loads.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/WsusManager.App/Program.cs
@src/WsusManager.App/ViewModels/MainViewModel.cs
@src/WsusManager.Core/Services/DashboardService.cs
@src/WsusManager.Core/Services/SqlService.cs

Phase 22 BenchmarkDotNet infrastructure already exists — will measure startup time before and after changes.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DashboardService status caching with TTL</name>
  <files>src/WsusManager.Core/Services/DashboardService.cs</files>
  <action>
    Add server status caching to DashboardService to prevent redundant queries during rapid startup calls:

    1. Add private fields to DashboardService class:
       - `private DashboardStatus? _cachedStatus`
       - `private DateTime _cacheTimestamp`
       - `private const int CacheTtlSeconds = 5;`

    2. Modify CollectAsync method:
       - At start, check if cache is valid: `if (_cachedStatus != null && (DateTime.Now - _cacheTimestamp).TotalSeconds < CacheTtlSeconds) return _cachedStatus;`
       - After collecting status, update cache: `_cachedStatus = status; _cacheTimestamp = DateTime.Now;`

    3. Add public method to invalidate cache:
       - `public void InvalidateCache() { _cachedStatus = null; }`

    This prevents multiple service status queries during initialization when RefreshDashboard might be called multiple times.

    Do NOT add any external dependencies — use only System and existing types.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj --configuration Release` should succeed with 0 warnings.
  </verify>
  <done>
    DashboardService caches status for 5 seconds, reducing redundant SQL/service queries during startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Parallelize InitializeAsync in MainViewModel</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Refactor InitializeAsync to parallelize independent operations:

    Current sequential flow (slow):
    1. Load settings
    2. Apply settings
    3. RefreshDashboard (blocks on SQL/services)
    4. Check WSUS installation
    5. Start timer

    New parallel flow:
    1. Start settings load in background
    2. Start dashboard data fetch in background (independent of settings)
    3. Await both with Task.WhenAll
    4. Apply settings after loaded
    5. Check WSUS installation (uses dashboard data)
    6. Start timer

    Implementation:
    - Change `InitializeAsync` to:
      ```csharp
      var settingsTask = _settingsService.LoadAsync();
      var dashboardTask = _dashboardService.CollectAsync();

      await Task.WhenAll(settingsTask, dashboardTask).ConfigureAwait(false);

      _settings = settingsTask.Result;
      var dashboardData = dashboardTask.Result;

      ApplySettings(_settings);
      UpdateDashboardFromData(dashboardData);
      // ... rest of init
      ```

    - Extract dashboard update logic from RefreshDashboard into private method `UpdateDashboardFromData(DashboardStatus status)` that takes cached data instead of calling CollectAsync again.

    - Keep RefreshDashboard as wrapper that calls CollectAsync then UpdateDashboardFromData for normal refreshes.

    This allows settings load and dashboard data collection to run in parallel.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release` should succeed.
  </verify>
  <done>
    InitializeAsync runs settings load and dashboard fetch in parallel using Task.WhenAll.
  </done>
</task>

<task type="auto">
  <name>Task 3: Defer theme resource preloading in Program.cs</name>
  <files>src/WsusManager.App/Program.cs</files>
  <action>
    Move theme application to after MainWindow creation to allow window to render sooner:

    Current sequence (blocks render):
    1. Create host
    2. Initialize app component
    3. Apply theme (blocks on resource dictionary merging)
    4. Create MainWindow
    5. Run app

    New sequence (renders earlier):
    1. Create host
    2. Initialize app component
    3. Create MainWindow (construction, not theme-aware yet)
    4. Apply theme (now window exists, can apply async)
    5. Run app

    Implementation:
    - Move lines 42-45 (themeService.ApplyTheme) to after line 47 (MainWindow creation)
    - This allows MainWindow constructor to complete before theme merging begins
    - Theme will apply slightly later but window appears sooner to user

    Note: SettingsService.Current is already synchronous/cached, so no blocking there.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release` should succeed.
  </verify>
  <done>
    MainWindow created before theme application, reducing time to first window render.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Build Release configuration: `dotnet build src/WsusManager.sln --configuration Release`
2. Run startup benchmark: `dotnet run --project src/WsusManager.Benchmarks -c Release --filter "*Startup*"`
3. Verify cold startup time < 1500ms (30% improvement from v4.4 baseline of ~2000ms)
4. Manual test: Launch application and observe UI shell appears before dashboard cards populate
</verification>

<success_criteria>
1. Application cold startup completes within 1.5 seconds (measured by BenchmarkDotNet or manual stopwatch from launch to window visible)
2. UI shell (sidebar, header, layout) renders before dashboard data loads
3. Settings file load happens in parallel with dashboard data fetch
4. No new compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/25-performance-optimization/25-01-SUMMARY.md` with:
- Actual startup time measurements (before/after)
- Task.WhenAll parallelization confirmation
- Any deviations from plan
</output>
