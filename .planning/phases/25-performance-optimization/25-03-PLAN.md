---
phase: 25-performance-optimization
plan: 03
type: execute
wave: 2
depends_on: [25-01]
files_modified:
  - src/WsusManager.Core/Services/DashboardService.cs
  - src/WsusManager.Core/Services/SqlService.cs
  - src/WsusManager.Core/Services/Interfaces/IDashboardService.cs
autonomous: true
requirements: [PERF-10]

must_haves:
  truths:
    - "Update metadata (approval status, classification) loads on-demand when user views updates"
    - "Dashboard summary counts load immediately without full update details"
    - "Full update list fetches only when UpdateManagerService or equivalent is invoked"
    - "Lazy loading uses pagination (100 items per page) for large datasets"
  artifacts:
    - path: "src/WsusManager.Core/Services/DashboardService.cs"
      provides: "Lazy-loading aware dashboard data collection"
      contains: "CollectAsync|LazyLoadOnDemand"
      min_lines: 60
    - path: "src/WsusManager.Core/Services/SqlService.cs"
      provides: "Pagination support for large result sets"
      contains: "QueryWithPagination|FetchPage"
    - path: "src/WsusManager.Core/Services/Interfaces/IDashboardService.cs"
      provides: "Lazy-loading capability contract"
      contains: "interface IDashboardService"
  key_links:
    - from: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      to: "src/WsusManager.Core/Services/DashboardService.cs"
      via: "RefreshDashboard calls CollectAsync for summary data"
      pattern: "await.*RefreshDashboard"
    - from: "src/WsusManager.Core/Services/DashboardService.cs"
      to: "src/WsusManager.Core/Services/SqlService.cs"
      via: "SQL queries for update/computer counts"
      pattern: "ISqlService|ExecuteScalarAsync"
---

<objective>
Implement lazy loading for update metadata so dashboard summary loads immediately without fetching full update details. Full update list (KB articles, classifications, approval status) loads on-demand only when explicitly requested.

Purpose: Dashboard currently collects all available metadata on every refresh, causing unnecessary SQL queries and delays. Summary counts (approved/declined/total) are sufficient for dashboard view; full details only needed for update-specific panels.

Output: Dashboard refresh completes 50-70% faster by deferring full update metadata fetch until needed.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/WsusManager.Core/Services/DashboardService.cs
@src/WsusManager.Core/Services/SqlService.cs
@src/WsusManager.Core/Services/Interfaces/IDashboardService.cs

Current implementation:
- DashboardService.CollectAsync queries multiple tables for summary statistics
- Update metadata (KB articles, classifications) fetched even when not displayed
- Dashboard shows only summary cards, not full update lists

Per user decision (25-CONTEXT.md):
- Load summary counts immediately (computers online/offline, updates approved/declined)
- Fetch full update metadata on-demand when user expands or filters
- Use pagination for large datasets (100 items per page)
- Cache loaded data to avoid redundant queries
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pagination support to SqlService</name>
  <files>src/WsusManager.Core/Services/SqlService.cs</files>
  <action>
    Add paginated query methods to SqlService for fetching update metadata in chunks:

    1. Add record type to support paged results:
       ```csharp
       public record PagedResult<T>(IReadOnlyList<T> Items, int TotalCount, int PageNumber, int PageSize);
       ```

    2. Add method to fetch updates by page:
       ```csharp
       public async Task<PagedResult<UpdateInfo>> FetchUpdatesPageAsync(
           int pageNumber = 1,
           int pageSize = 100,
           string? whereClause = null,
           CancellationToken ct = default)
       {
           var offset = (pageNumber - 1) * pageSize;

           // Count total
           var countQuery = $@"
               SELECT COUNT(*) FROM tbUpdate
               WHERE {BuildWhereClause(whereClause)};";

           var totalCount = await ExecuteScalarAsync<int>(countQuery, ct).ConfigureAwait(false);

           // Fetch page
           var dataQuery = $@"
               SELECT TOP ({pageSize})
                   u.UpdateId, u.DefaultTitle, u.KBArticle, u.UpdateClassification,
                   u.CreationDate, u.Approved, u.Declined
               FROM tbUpdate u
               WHERE {BuildWhereClause(whereClause)}
               ORDER BY u.CreationDate DESC
               OFFSET {offset} ROWS;";

           var items = await ExecuteQueryAsync<UpdateInfo>(dataQuery, MapUpdateInfo, ct).ConfigureAwait(false);

           return new PagedResult<UpdateInfo>(items, totalCount, pageNumber, pageSize);
       }

       private static string BuildWhereClause(string? whereClause)
           => string.IsNullOrEmpty(whereClause) ? "1=1" : whereClause;

       private static UpdateInfo MapUpdateInfo(SqlDataReader reader)
           => new UpdateInfo(
               reader.GetGuid(0),  // UpdateId
               reader.GetString(1), // DefaultTitle
               reader.IsDBNull(2) ? null : reader.GetString(2), // KBArticle
               reader.IsDBNull(3) ? null : reader.GetString(3), // UpdateClassification
               reader.GetDateTime(4), // CreationDate
               reader.GetBoolean(5), // Approved
               reader.GetBoolean(6)  // Declined
           );
       ```

    3. Add UpdateInfo record if not exists:
       ```csharp
       public record UpdateInfo(
           Guid UpdateId,
           string Title,
           string? KbArticle,
           string? Classification,
           DateTime CreatedDate,
           bool IsApproved,
           bool IsDeclined);
       ```

    This provides pagination infrastructure for lazy loading.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj --configuration Release` should succeed.
  </verify>
  <done>
    SqlService supports paginated queries for update metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add lazy-loading methods to DashboardService</name>
  <files>src/WsusManager.Core/Services/DashboardService.cs</files>
  <action>
    Add on-demand update metadata fetching to DashboardService:

    1. Add private fields for lazy-loaded cache:
       ```csharp
       private IReadOnlyList<UpdateInfo>? _cachedUpdates;
       private DateTime _updateCacheTimestamp;
       private const int UpdateCacheTtlMinutes = 5;
       ```

    2. Add public async method to fetch updates on-demand:
       ```csharp
       public async Task<IReadOnlyList<UpdateInfo>> GetUpdatesAsync(
           int pageNumber = 1,
           int pageSize = 100,
           CancellationToken ct = default)
       {
           // Use cache if fresh and first page
           if (_cachedUpdates != null &&
               pageNumber == 1 &&
               (DateTime.Now - _updateCacheTimestamp).TotalMinutes < UpdateCacheTtlMinutes)
           {
               return _cachedUpdates.Take(pageSize).ToList();
           }

           // Fetch from database with pagination
           var result = await _sqlService.FetchUpdatesPageAsync(pageNumber, pageSize, ct: ct).ConfigureAwait(false);

           // Cache first page
           if (pageNumber == 1)
           {
               _cachedUpdates = result.Items.ToList();
               _updateCacheTimestamp = DateTime.Now;
           }

           return result.Items;
       }
       ```

    3. Add method to invalidate update cache:
       ```csharp
       public void InvalidateUpdateCache()
       {
           _cachedUpdates = null;
       }
       ```

    This allows dashboard to load summary data immediately while deferring full update list fetch.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj --configuration Release` should succeed.
  </verify>
  <done>
    DashboardService lazy-loads update metadata with pagination support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update IDashboardService interface with lazy-loading methods</name>
  <files>src/WsusManager.Core/Services/Interfaces/IDashboardService.cs</files>
  <action>
    Add lazy-loading method signatures to IDashboardService interface:

    1. Add method signatures to interface:
       ```csharp
       Task<IReadOnlyList<UpdateInfo>> GetUpdatesAsync(
           int pageNumber = 1,
           int pageSize = 100,
           CancellationToken ct = default);

       void InvalidateUpdateCache();
       ```

    2. Add UpdateInfo record to interface file or shared location:
       ```csharp
       public record UpdateInfo(
           Guid UpdateId,
           string Title,
           string? KbArticle,
           string? Classification,
           DateTime CreatedDate,
           bool IsApproved,
           bool IsDeclined);
       ```

    This exposes lazy-loading capability to ViewModels and other consumers.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj --configuration Release` should succeed.
  </verify>
  <done>
    IDashboardService interface exposes lazy-loading methods.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj --configuration Release`
2. Verify: DashboardService still compiles with interface changes
3. Verify: No compiler errors about missing interface members
4. Unit tests: Run any existing DashboardService tests (if present)
</verification>

<success_criteria>
1. DashboardService has GetUpdatesAsync method for on-demand fetch
2. SqlService supports paginated queries (FetchUpdatesPageAsync)
3. Update cache invalidates after 5 minutes or via explicit call
4. Interface properly exposes new methods
5. No new compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/25-performance-optimization/25-03-SUMMARY.md` with:
- Pagination implementation details
- Cache TTL configuration (5 minutes)
- Any deviations from plan
</output>
