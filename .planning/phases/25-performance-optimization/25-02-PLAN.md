---
phase: 25-performance-optimization
plan: 02
type: execute
wave: 2
depends_on: [25-01]
files_modified:
  - src/WsusManager.App/ViewModels/MainViewModel.cs
  - src/WsusManager.App/Views/MainWindow.xaml
autonomous: true
requirements: [PERF-11]

must_haves:
  truths:
    - "Log panel updates batch to 100ms chunks instead of every line"
    - "StringBuilder flushes to UI only when batch timer expires or operation completes"
    - "Long operations (1000+ lines) don't freeze UI due to excessive PropertyChanged notifications"
    - "Log output appears in near real-time (no perceived lag vs per-line updates)"
  artifacts:
    - path: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      provides: "Batched log updates with DispatcherTimer"
      contains: "AppendLog|_logBatchTimer|FlushLogBatch"
      min_lines: 50
    - path: "src/WsusManager.App/Views/MainWindow.xaml"
      provides: "LogOutput TextBox binding"
      contains: "LogOutput"
  key_links:
    - from: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      to: "src/WsusManager.App/Views/MainWindow.xaml"
      via: "LogOutput property binding"
      pattern: "Text=\"{Binding LogOutput"
    - from: "RunOperationAsync"
      to: "AppendLog"
      via: "Progress<string> callback routes to AppendLog"
      pattern: "progress\.Report.*AppendLog"
---

<objective>
Implement batched log panel updates to reduce UI thread overhead from PropertyChanged notifications. Instead of updating LogOutput property on every line (causing layout recalculation), batch lines and flush every 100ms or when operation completes.

Purpose: Operations with verbose output (1000+ lines) currently cause UI thread stress from per-line PropertyChanged events. Batching reduces thread overhead while maintaining real-time feedback.

Output: Log panel updates in 100ms chunks, reducing PropertyChanged notifications by ~90% for verbose operations.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/WsusManager.App/ViewModels/MainViewModel.cs
@src/WsusManager.App/Views/MainWindow.xaml

Current implementation (lines 341-366 in MainViewModel.cs):
- AppendLog adds line to StringBuilder
- LogOutput property set triggers PropertyChanged
- Each operation line causes UI layout recalculation
- For 1000+ line operations, this is ~1000 PropertyChanged events

Per user decision (25-CONTEXT.md):
- Batch 50 lines per chunk
- Flush every 100ms using DispatcherTimer
- Use Dispatcher.BeginInvoke with Normal priority
- Preserve order with concurrent queue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batching infrastructure to MainViewModel</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Add batching fields and timer to MainViewModel class (near existing private fields around line 42-48):

    ```csharp
    private readonly Queue<string> _logBatchQueue = new();
    private DispatcherTimer? _logBatchTimer;
    private const int LogBatchSize = 50;  // Lines per batch
    private const int LogBatchIntervalMs = 100;  // Flush interval
    ```

    Add IDisposable cleanup for timer in existing Dispose method (around line 1407):
    - Before `if (_disposed) return;`, add:
      ```csharp
      _logBatchTimer?.Stop();
      _logBatchTimer = null;
      ```

    This prepares the batching infrastructure without changing existing behavior yet.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release` should succeed.
  </verify>
  <done>
    Batching infrastructure fields added, timer cleanup in Dispose method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify AppendLog to use batching queue</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Refactor AppendLog method (currently lines 341-366) to use batching:

    1. Change AppendLog to:
       ```csharp
       public void AppendLog(string line)
       {
           // Add to batch queue
           lock (_logBatchQueue)
           {
               _logBatchQueue.Enqueue(line);

               // If batch size reached, flush immediately
               if (_logBatchQueue.Count >= LogBatchSize)
               {
                   FlushLogBatch();
               }
               else if (_logBatchTimer == null)
               {
                   // Start timer on first queued item
                   StartLogBatchTimer();
               }
           }
       }
       ```

    2. Add private method StartLogBatchTimer:
       ```csharp
       private void StartLogBatchTimer()
       {
           _logBatchTimer = new DispatcherTimer
           {
               Interval = TimeSpan.FromMilliseconds(LogBatchIntervalMs)
           };
           _logBatchTimer.Tick += (s, e) =>
           {
               FlushLogBatch();
               _logBatchTimer?.Stop();
           };
           _logBatchTimer.Start();
           Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Normal, new Action(() => { }));
       }
       ```

    3. Modify existing StringBuilder trimming logic to move into FlushLogBatch method (see Task 3).

    This queues lines instead of immediately updating LogOutput property.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release` should succeed.
  </verify>
  <done>
    AppendLog queues lines, flushes on batch size or timer expiry.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement FlushLogBatch method</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Add FlushLogBatch method that processes queued lines and updates LogOutput:

    ```csharp
    private void FlushLogBatch()
    {
        string[] batch;
        lock (_logBatchQueue)
        {
            if (_logBatchQueue.Count == 0) return;
            batch = _logBatchQueue.ToArray();
            _logBatchQueue.Clear();
        }

        // Add all lines to StringBuilder
        foreach (var line in batch)
        {
            _logBuilder.AppendLine(line);
        }

        // Trim to last 1000 lines to prevent unbounded growth (~100KB limit)
        // (Move existing trimming logic from AppendLog here, lines 349-363)
        if (_logBuilder.Length > 100_000)
        {
            var fullText = _logBuilder.ToString();
            var lines = fullText.Split('\n');
            if (lines.Length > 1000)
            {
                _logBuilder.Clear();
                var start = lines.Length - 1000;
                for (int i = start; i < lines.Length; i++)
                {
                    _logBuilder.AppendLine(lines[i]);
                }
            }
        }

        // Single UI update for entire batch
        LogOutput = _logBuilder.ToString();
    }
    ```

    Also update RunOperationAsync finally block (around line 328-339) to flush any remaining logs:
    - After `NotifyCommandCanExecuteChanged();` add:
      ```csharp
      FlushLogBatch();  // Ensure final batch is displayed
      ```

    This ensures all logged lines appear even if operation completes before batch timer fires.
  </action>
  <verify>
    Build: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release` should succeed.
  </verify>
  <done>
    FlushLogBatch processes queued lines, trims log, updates UI once per batch.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Build Release: `dotnet build src/WsusManager.App/WsusManager.App.csproj --configuration Release`
2. Manual test: Run Diagnostics operation (produces ~50-100 lines)
3. Verify: Log output appears smoothly, no lag, lines appear in groups (batched)
4. Manual test: Run Deep Cleanup (produces ~1000+ lines)
5. Verify: UI remains responsive, no freezing, all lines appear by operation end
6. Verify: Clear Log button still works (calls _logBuilder.Clear() which is compatible)
</verification>

<success_criteria>
1. Log panel updates in 100ms chunks (observable via lines appearing in groups)
2. PropertyChanged notifications reduced by ~90% for verbose operations
3. No log lines lost (all output appears by operation completion)
4. Clear Log button still functions correctly
5. No new compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/25-performance-optimization/25-02-SUMMARY.md` with:
- PropertyChanged reduction metrics (estimated vs actual)
- Verification results from Diagnostics/Deep Cleanup operations
- Any UI threading issues observed and resolved
</output>
