# Phase 31-02: Unit Tests for New Features

**Created:** 2026-02-21
**Status:** Complete
**Requirement:** Test coverage for Phases 26, 28, 29, 30
**Dependencies:** Phases 26, 28, 29, 30 (implementation complete)

## Goal

Create comprehensive unit tests for new v4.5 features: keyboard navigation (Phase 26), settings persistence (Phase 28), data filtering (Phase 29), and CSV export (Phase 30). Achieve 80%+ code coverage on new code and verify no regressions in existing functionality.

## Success Criteria (Observable Truths)

1. `KeyboardNavigationTests.cs` extended with 10+ new tests for Phase 26 features
2. `SettingsPersistenceTests.cs` created with 12+ tests for Phase 28 features
3. `DataFilteringTests.cs` created with 15+ tests for Phase 29 features
4. `CsvExportServiceTests.cs` created with 12+ tests for Phase 30 features
5. All new tests pass (100% pass rate)
6. Code coverage report shows 80%+ line coverage on new code
7. No existing tests broken by new features

## Changes Required

### 1. Extend KeyboardNavigationTests (Phase 26)

**File:** `/mnt/c/projects/GA-WsusManager/src/WsusManager.Tests/KeyboardNavigationTests.cs`

Add tests for:
- Global keyboard shortcuts (F1, F5, Ctrl+S, Ctrl+Q, Escape)
- AutomationId attributes on all interactive elements
- Dialog centering behavior
- Tab navigation order
- Arrow key navigation in lists/comboboxes

```csharp
[Theory]
[InlineData("DashboardButton")]
[InlineData("ComputersButton")]
[InlineData("UpdatesButton")]
[InlineData("DiagnosticsButton")]
[InlineData("SettingsButton")]
[InlineData("HelpButton")]
public void NavigationButtons_ShouldHaveAutomationId(string automationId)
{
    var content = File.ReadAllText(GetXamlPath("MainWindow.xaml"));
    Assert.Contains($"AutomationId=\"{automationId}\"", content);
}

[Fact]
public void AllDialogs_ShouldHaveCenterOwner()
{
    var dialogFiles = new[]
    {
        "SettingsDialog.xaml",
        "SyncProfileDialog.xaml",
        "TransferDialog.xaml",
        "ScheduleTaskDialog.xaml",
        "InstallDialog.xaml"
    };

    foreach (var dialogFile in dialogFiles)
    {
        var content = File.ReadAllText(GetXamlPath(dialogFile));
        Assert.Contains("WindowStartupLocation=\"CenterOwner\"", content,
            $"{dialogFile} should use CenterOwner for centering");
    }
}

[Theory]
[InlineData("MainWindow.xaml", "Key=\"F1\"")]
[InlineData("MainWindow.xaml", "Key=\"F5\"")]
[InlineData("MainWindow.xaml", "Key=\"S\" Modifiers=\"Control\"")]
[InlineData("MainWindow.xaml", "Key=\"Q\" Modifiers=\"Control\"")]
[InlineData("MainWindow.xaml", "Key=\"Escape\"")]
public void KeyboardShortcuts_ShouldBeDefined(string fileName, string shortcut)
{
    var content = File.ReadAllText(GetXamlPath(fileName));
    Assert.Contains(shortcut, content);
}
```

### 2. Create SettingsPersistenceTests (Phase 28)

**File:** `/mnt/c/projects/GA-WsusManager/src/WsusManager.Tests/Services/SettingsPersistenceTests.cs`

```csharp
using System.Text.Json;
using Xunit;
using Moq;
using WsusManager.Core.Services.Interfaces;
using WsusManager.Core.Models;

namespace WsusManager.Tests.Services;

/// <summary>
/// Unit tests for settings persistence (Phase 28).
/// Tests save/load, default values, validation, and reset to defaults.
/// </summary>
public class SettingsPersistenceTests
{
    private readonly Mock<IFileService> _mockFileService;
    private readonly SettingsService _settingsService;
    private readonly string _testSettingsPath;

    public SettingsPersistenceTests()
    {
        _mockFileService = new Mock<IFileService>();
        _testSettingsPath = Path.Combine(Path.GetTempPath(), "test-settings.json");
        _settingsService = new SettingsService(_mockFileService.Object, _testSettingsPath);
    }

    [Fact]
    public async Task SaveSettingsAsync_ShouldWriteToFile()
    {
        // Arrange
        var settings = new AppSettings
        {
            DefaultSyncProfile = DefaultSyncProfile.Quick,
            LogLevel = LogLevel.Debug,
            LogRetentionDays = 60
        };

        // Act
        await _settingsService.SaveSettingsAsync(settings);

        // Assert
        _mockFileService.Verify(f => f.WriteAllTextAsync(
            _testSettingsPath,
            It.Is<string>(json => json.Contains("Quick") && json.Contains("Debug")),
            It.IsAny<CancellationToken>()), Times.Once);
    }

    [Fact]
    public async Task LoadSettingsAsync_ShouldReturnDefaultsWhenFileMissing()
    {
        // Arrange
        _mockFileService.Setup(f => f.FileExists(_testSettingsPath)).Returns(false);

        // Act
        var settings = await _settingsService.LoadSettingsAsync();

        // Assert
        Assert.Equal(DefaultSyncProfile.Full, settings.DefaultSyncProfile);
        Assert.Equal(LogLevel.Info, settings.LogLevel);
        Assert.Equal(30, settings.LogRetentionDays);
        Assert.Equal(10, settings.LogMaxFileSizeMb);
        Assert.True(settings.PersistWindowState);
        Assert.True(settings.RequireConfirmationDestructive);
    }

    [Fact]
    public async Task LoadSettingsAsync_ShouldDeserializeJson()
    {
        // Arrange
        var json = """{
            "DefaultSyncProfile": "Quick",
            "LogLevel": "Debug",
            "LogRetentionDays": 90,
            "LogMaxFileSizeMb": 50
        }""";
        _mockFileService.Setup(f => f.FileExists(_testSettingsPath)).Returns(true);
        _mockFileService.Setup(f => f.ReadAllTextAsync(_testSettingsPath, It.IsAny<CancellationToken>()))
            .ReturnsAsync(json);

        // Act
        var settings = await _settingsService.LoadSettingsAsync();

        // Assert
        Assert.Equal(DefaultSyncProfile.Quick, settings.DefaultSyncProfile);
        Assert.Equal(LogLevel.Debug, settings.LogLevel);
        Assert.Equal(90, settings.LogRetentionDays);
        Assert.Equal(50, settings.LogMaxFileSizeMb);
    }

    [Fact]
    public void WindowBounds_ShouldSerializeCorrectly()
    {
        // Arrange
        var bounds = new WindowBounds
        {
            Width = 1920,
            Height = 1080,
            Left = 100,
            Top = 100,
            WindowState = "Maximized"
        };
        var settings = new AppSettings { WindowBounds = bounds };

        // Act
        var json = JsonSerializer.Serialize(settings);
        var deserialized = JsonSerializer.Deserialize<AppSettings>(json);

        // Assert
        Assert.NotNull(deserialized!.WindowBounds);
        Assert.Equal(1920, deserialized.WindowBounds.Width);
        Assert.Equal(1080, deserialized.WindowBounds.Height);
        Assert.Equal(100, deserialized.WindowBounds.Left);
        Assert.Equal(100, deserialized.WindowBounds.Top);
        Assert.Equal("Maximized", deserialized.WindowBounds.WindowState);
    }

    [Theory]
    [InlineData(0, 1)]   // Min boundary
    [InlineData(365, 365)] // Max boundary
    [InlineData(30, 30)]  // Default
    public void LogRetentionDays_ShouldValidateRange(int input, int expected)
    {
        // Arrange
        var settings = new AppSettings { LogRetentionDays = input };

        // Act & Assert
        Assert.Equal(expected, settings.LogRetentionDays);
    }

    [Theory]
    [InlineData(1, 1)]     // Min boundary
    [InlineData(1000, 1000)] // Max boundary
    [InlineData(10, 10)]    // Default
    public void LogMaxFileSizeMb_ShouldValidateRange(int input, int expected)
    {
        // Arrange
        var settings = new AppSettings { LogMaxFileSizeMb = input };

        // Act & Assert
        Assert.Equal(expected, settings.LogMaxFileSizeMb);
    }

    [Theory]
    [InlineData(10, 10)]   // Min boundary
    [InlineData(300, 300)] // Max boundary
    [InlineData(60, 60)]   // Default
    public void WinRMTimeoutSeconds_ShouldValidateRange(int input, int expected)
    {
        // Arrange
        var settings = new AppSettings { WinRMTimeoutSeconds = input };

        // Act & Assert
        Assert.Equal(expected, settings.WinRMTimeoutSeconds);
    }

    [Theory]
    [InlineData(1, 1)]    // Min boundary
    [InlineData(10, 10)]  // Max boundary
    [InlineData(3, 3)]    // Default
    public void WinRMRetryCount_ShouldValidateRange(int input, int expected)
    {
        // Arrange
        var settings = new AppSettings { WinRMRetryCount = input };

        // Act & Assert
        Assert.Equal(expected, settings.WinRMRetryCount);
    }

    [Fact]
    public async Task ResetToDefaultsAsync_ShouldRestoreAllDefaults()
    {
        // Arrange
        var settings = new AppSettings
        {
            DefaultSyncProfile = DefaultSyncProfile.Quick,
            LogLevel = LogLevel.Fatal,
            LogRetentionDays = 365,
            LogMaxFileSizeMb = 1000,
            PersistWindowState = false,
            RequireConfirmationDestructive = false,
            DashboardRefreshInterval = DashboardRefreshInterval.Disabled,
            WinRMTimeoutSeconds = 300,
            WinRMRetryCount = 10
        };

        // Act
        await _settingsService.ResetToDefaultsAsync(settings);

        // Assert
        Assert.Equal(DefaultSyncProfile.Full, settings.DefaultSyncProfile);
        Assert.Equal(LogLevel.Info, settings.LogLevel);
        Assert.Equal(30, settings.LogRetentionDays);
        Assert.Equal(10, settings.LogMaxFileSizeMb);
        Assert.True(settings.PersistWindowState);
        Assert.True(settings.RequireConfirmationDestructive);
        Assert.Equal(DashboardRefreshInterval.Sec30, settings.DashboardRefreshInterval);
        Assert.Equal(60, settings.WinRMTimeoutSeconds);
        Assert.Equal(3, settings.WinRMRetryCount);
    }
}
```

### 3. Create DataFilteringTests (Phase 29)

**File:** `/mnt/c/projects/GA-WsusManager/src/WsusManager.Tests/ViewModels/DataFilteringTests.cs`

```csharp
using Xunit;
using WsusManager.Core.Models;
using WsusManager.App.ViewModels;

namespace WsusManager.Tests.ViewModels;

/// <summary>
/// Unit tests for data filtering (Phase 29).
/// Tests status filters, classification filters, search debounce, and clear filters.
/// </summary>
public class DataFilteringTests
{
    [Fact]
    public void ComputerStatusFilter_All_ShowsAllComputers()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.ComputerStatusFilter = "All";
        var computers = CreateMockComputers(10);

        // Act
        viewModel.LoadComputers(computers);
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Equal(10, viewModel.FilteredComputers.Count);
    }

    [Fact]
    public void ComputerStatusFilter_Online_ShowsOnlyOnline()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.ComputerStatusFilter = "Online";
        var computers = CreateMockComputers(10);

        // Act
        viewModel.LoadComputers(computers);
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.All(viewModel.FilteredComputers, c => Assert.Equal("Online", c.Status));
    }

    [Fact]
    public void ComputerStatusFilter_Offline_ShowsOnlyOffline()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.ComputerStatusFilter = "Offline";
        var computers = CreateMockComputers(10);

        // Act
        viewModel.LoadComputers(computers);
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.All(viewModel.FilteredComputers, c => Assert.Equal("Offline", c.Status));
    }

    [Fact]
    public void UpdateApprovalFilter_Approved_ShowsOnlyApproved()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.UpdateApprovalFilter = "Approved";
        var updates = CreateMockUpdates(20);

        // Act
        viewModel.LoadUpdates(updates);
        viewModel.ApplyUpdateFilters();

        // Assert
        Assert.All(viewModel.FilteredUpdates, u => Assert.Equal("Approved", u.ApprovalStatus));
    }

    [Fact]
    public void UpdateClassificationFilter_Critical_ShowsOnlyCritical()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.UpdateClassificationFilter = "Critical";
        var updates = CreateMockUpdates(20);

        // Act
        viewModel.LoadUpdates(updates);
        viewModel.ApplyUpdateFilters();

        // Assert
        Assert.All(viewModel.FilteredUpdates, u => Assert.Equal("Critical", u.Classification));
    }

    [Fact]
    public void SearchText_FiltersComputersByHostname()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var computers = CreateMockComputers(10);
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ComputerSearchText = "COMPUTER-0001";
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Single(viewModel.FilteredComputers);
        Assert.Equal("COMPUTER-0001", viewModel.FilteredComputers[0].Hostname);
    }

    [Fact]
    public void SearchText_FiltersUpdatesByKbNumber()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var updates = CreateMockUpdates(20);
        viewModel.LoadUpdates(updates);

        // Act
        viewModel.UpdateSearchText = "KB500001";
        viewModel.ApplyUpdateFilters();

        // Assert
        Assert.Single(viewModel.FilteredUpdates);
        Assert.Equal("KB500001", viewModel.FilteredUpdates[0].KbNumber);
    }

    [Fact]
    public void SearchText_IsCaseInsensitive()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var computers = CreateMockComputers(10);
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ComputerSearchText = "computer-0001";
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Single(viewModel.FilteredComputers);
    }

    [Fact]
    public void MultipleFilters_AreAppliedWithAndLogic()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.UpdateApprovalFilter = "Approved";
        viewModel.UpdateClassificationFilter = "Critical";
        var updates = CreateMockUpdates(100);
        viewModel.LoadUpdates(updates);

        // Act
        viewModel.ApplyUpdateFilters();

        // Assert
        Assert.All(viewModel.FilteredUpdates, u =>
        {
            Assert.Equal("Approved", u.ApprovalStatus);
            Assert.Equal("Critical", u.Classification);
        });
    }

    [Fact]
    public void ClearComputerFiltersCommand_ResetsAllFilters()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.ComputerStatusFilter = "Online";
        viewModel.ComputerSearchText = "test";
        var computers = CreateMockComputers(10);
        viewModel.LoadComputers(computers);
        viewModel.ApplyComputerFilters();

        // Act
        viewModel.ClearComputerFiltersCommand.Execute(null);

        // Assert
        Assert.Equal("All", viewModel.ComputerStatusFilter);
        Assert.Empty(viewModel.ComputerSearchText);
        Assert.Equal(10, viewModel.FilteredComputers.Count);
    }

    [Fact]
    public void ClearUpdateFiltersCommand_ResetsAllFilters()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.UpdateApprovalFilter = "Approved";
        viewModel.UpdateClassificationFilter = "Security";
        viewModel.UpdateSearchText = "KB";
        var updates = CreateMockUpdates(20);
        viewModel.LoadUpdates(updates);
        viewModel.ApplyUpdateFilters();

        // Act
        viewModel.ClearUpdateFiltersCommand.Execute(null);

        // Assert
        Assert.Equal("All", viewModel.UpdateApprovalFilter);
        Assert.Equal("All", viewModel.UpdateClassificationFilter);
        Assert.Empty(viewModel.UpdateSearchText);
        Assert.Equal(20, viewModel.FilteredUpdates.Count);
    }

    [Fact]
    public void SearchDebounce_Waits300msBeforeFiltering()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var computers = CreateMockComputers(100);
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ComputerSearchText = "test";
        // Immediately check - should not filter yet
        Assert.Equal(100, viewModel.FilteredComputers.Count);

        // Wait for debounce timer
        Thread.Sleep(350);

        // Now filtering should be applied
        // Note: This test requires integration testing with actual DispatcherTimer
    }

    [Fact]
    public void EmptyFilters_ShowsAllItems()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var computers = CreateMockComputers(50);
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Equal(50, viewModel.FilteredComputers.Count);
    }

    [Fact]
    public void FilterWithNoMatches_ReturnsEmptyList()
    {
        // Arrange
        var viewModel = CreateViewModel();
        viewModel.ComputerSearchText = "NONEXISTENT";
        var computers = CreateMockComputers(10);
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Empty(viewModel.FilteredComputers);
    }

    [Fact]
    public void SpecialCharactersInSearch_AreHandledCorrectly()
    {
        // Arrange
        var viewModel = CreateViewModel();
        var computers = new List<ComputerInfo>
        {
            new() { Hostname = "COMPUTER-TEST[1]", IpAddress = "192.168.1.1", Status = "Online" }
        };
        viewModel.LoadComputers(computers);

        // Act
        viewModel.ComputerSearchText = "[";
        viewModel.ApplyComputerFilters();

        // Assert
        Assert.Single(viewModel.FilteredComputers);
    }

    #region Helpers

    private static MainViewModel CreateViewModel()
    {
        // Mock DI container and create ViewModel
        // Implementation depends on actual DI setup
        throw new NotImplementedException("Create mock setup for MainViewModel");
    }

    private static List<ComputerInfo> CreateMockComputers(int count)
    {
        var computers = new List<ComputerInfo>(count);
        for (int i = 0; i < count; i++)
        {
            computers.Add(new ComputerInfo
            {
                Hostname = $"COMPUTER-{i:D4}",
                IpAddress = $"192.168.1.{i % 255 + 1}",
                Status = i % 3 == 0 ? "Online" : (i % 3 == 1 ? "Offline" : "Error"),
                LastSync = DateTime.Now.AddHours(-i % 48),
                PendingUpdates = i % 10,
                OsVersion = "Windows Server 2022"
            });
        }
        return computers;
    }

    private static List<UpdateInfo> CreateMockUpdates(int count)
    {
        var updates = new List<UpdateInfo>(count);
        var classifications = new[] { "Critical", "Security", "Definition", "Updates" };
        var statuses = new[] { "Approved", "Not Approved", "Declined" };

        for (int i = 0; i < count; i++)
        {
            updates.Add(new UpdateInfo
            {
                KbNumber = $"KB{i + 500000}",
                Title = $"Update {i + 1}",
                Classification = classifications[i % classifications.Length],
                ApprovalStatus = statuses[i % statuses.Length],
                ApprovalDate = DateTime.Now.AddDays(-i % 30),
                ReleasedDate = DateTime.Now.AddDays(-(i % 30 + 1))
            });
        }
        return updates;
    }

    #endregion
}
```

### 4. Create CsvExportServiceTests (Phase 30)

**File:** `/mnt/c/projects/GA-WsusManager/src/WsusManager.Tests/Services/CsvExportServiceTests.cs`

```csharp
using Xunit;
using Xunit.Abstractions;
using WsusManager.Core.Services;
using WsusManager.Core.Models;
using System.Text;

namespace WsusManager.Tests.Services;

/// <summary>
/// Unit tests for CSV export service (Phase 30).
/// Tests UTF-8 BOM, CSV format, field escaping, and cancellation.
/// </summary>
public class CsvExportServiceTests
{
    private readonly ITestOutputHelper _output;
    private readonly CsvExportService _service;
    private readonly string _tempPath;

    public CsvExportServiceTests(ITestOutputHelper output)
    {
        _output = output;
        _service = new CsvExportService();
        _tempPath = Path.Combine(Path.GetTempPath(), $"csv-test-{Guid.NewGuid()}");
        Directory.CreateDirectory(_tempPath);
    }

    public void Dispose()
    {
        if (Directory.Exists(_tempPath))
        {
            Directory.Delete(_tempPath, true);
        }
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldCreateCsvFile()
    {
        // Arrange
        var computers = CreateMockComputers(5);
        var outputPath = Path.Combine(_tempPath, "test-computers.csv");

        // Act
        var resultPath = await _service.ExportComputersAsync(computers, null, CancellationToken.None);

        // Assert
        Assert.True(File.Exists(resultPath));
        Assert.True(File.Exists(outputPath) || resultPath.Contains("WsusManager-Computers"));
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldIncludeUtf8Bom()
    {
        // Arrange
        var computers = CreateMockComputers(1);
        var progress = new Progress<string>(msg => _output.WriteLine(msg));

        // Act
        var filePath = await _service.ExportComputersAsync(computers, progress, CancellationToken.None);
        var bytes = await File.ReadAllBytesAsync(filePath);

        // Assert - First 3 bytes should be UTF-8 BOM (EF BB BF)
        Assert.Equal(0xEF, bytes[0]);
        Assert.Equal(0xBB, bytes[1]);
        Assert.Equal(0xBF, bytes[2]);
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldIncludeHeaderRow()
    {
        // Arrange
        var computers = CreateMockComputers(1);

        // Act
        var filePath = await _service.ExportComputersAsync(computers, null, CancellationToken.None);
        var content = await File.ReadAllTextAsync(filePath);

        // Assert
        Assert.Contains("Hostname,IP Address,Status,Last Sync,Pending Updates,OS Version", content);
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldEscapeCommas()
    {
        // Arrange
        var computers = new List<ComputerInfo>
        {
            new() { Hostname = "COMPUTER,TEST", IpAddress = "192.168.1.1", Status = "Online", LastSync = DateTime.Now, PendingUpdates = 0, OsVersion = "Windows" }
        };

        // Act
        var filePath = await _service.ExportComputersAsync(computers, null, CancellationToken.None);
        var content = await File.ReadAllTextAsync(filePath);

        // Assert - Comma should be quoted
        Assert.Contains("\"COMPUTER,TEST\"", content);
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldEscapeQuotes()
    {
        // Arrange
        var computers = new List<ComputerInfo>
        {
            new() { Hostname = "COMPUTER\"TEST", IpAddress = "192.168.1.1", Status = "Online", LastSync = DateTime.Now, PendingUpdates = 0, OsVersion = "Windows" }
        };

        // Act
        var filePath = await _service.ExportComputersAsync(computers, null, CancellationToken.None);
        var content = await File.ReadAllTextAsync(filePath);

        // Assert - Quote should be doubled
        Assert.Contains("\"COMPUTER\"\"TEST\"", content);
    }

    [Fact]
    public async Task ExportComputersAsync_ShouldExportAllComputers()
    {
        // Arrange
        var computers = CreateMockComputers(100);

        // Act
        var filePath = await _service.ExportComputersAsync(computers, null, CancellationToken.None);
        var lines = await File.ReadAllLinesAsync(filePath);

        // Assert - Header + 100 data rows
        Assert.Equal(101, lines.Length);
    }

    [Fact]
    public async Task ExportUpdatesAsync_ShouldIncludeAllColumns()
    {
        // Arrange
        var updates = CreateMockUpdates(1);

        // Act
        var filePath = await _service.ExportUpdatesAsync(updates, null, CancellationToken.None);
        var content = await File.ReadAllTextAsync(filePath);

        // Assert
        Assert.Contains("KB Number,Title,Classification,Approval Status,Approval Date,Released Date", content);
    }

    [Fact]
    public async Task ExportUpdatesAsync_ShouldIncludeUtf8Bom()
    {
        // Arrange
        var updates = CreateMockUpdates(1);

        // Act
        var filePath = await _service.ExportUpdatesAsync(updates, null, CancellationToken.None);
        var bytes = await File.ReadAllBytesAsync(filePath);

        // Assert
        Assert.Equal(0xEF, bytes[0]);
        Assert.Equal(0xBB, bytes[1]);
        Assert.Equal(0xBF, bytes[2]);
    }

    [Fact]
    public async Task Export_ShouldReportProgress()
    {
        // Arrange
        var computers = CreateMockComputers(250);
        var progressMessages = new List<string>();
        var progress = new Progress<string>(msg => progressMessages.Add(msg));

        // Act
        await _service.ExportComputersAsync(computers, progress, CancellationToken.None);

        // Assert - Should report progress at least twice (100-item batches)
        Assert.True(progressMessages.Count >= 2);
        Assert.Contains("Exported", progressMessages[0]);
    }

    [Fact]
    public async Task Export_ShouldRespectCancellation()
    {
        // Arrange
        var computers = CreateMockComputers(10000);
        var cts = new CancellationTokenSource();

        // Act - Cancel immediately
        cts.Cancel();
        var exception = await Record.ExceptionAsync(async () =>
        {
            await _service.ExportComputersAsync(computers, null, cts.Token);
        });

        // Assert - Should throw OperationCanceledException
        Assert.IsType<OperationCanceledException>(exception);
    }

    [Fact]
    public async Task ExportUpdatesAsync_ShouldHandleSpecialCharacters()
    {
        // Arrange
        var updates = new List<UpdateInfo>
        {
            new()
            {
                KbNumber = "KB123456",
                Title = "Update with \"quotes\" and, commas",
                Classification = "Security",
                ApprovalStatus = "Approved",
                ApprovalDate = DateTime.Now,
                ReleasedDate = DateTime.Now.AddDays(-1)
            }
        };

        // Act
        var filePath = await _service.ExportUpdatesAsync(updates, null, CancellationToken.None);
        var content = await File.ReadAllTextAsync(filePath);

        // Assert
        Assert.Contains("\"\"quotes\"\" and, commas\"", content);
    }

    #region Helpers

    private static List<ComputerInfo> CreateMockComputers(int count)
    {
        var computers = new List<ComputerInfo>(count);
        for (int i = 0; i < count; i++)
        {
            computers.Add(new ComputerInfo
            {
                Hostname = $"COMPUTER-{i:D4}",
                IpAddress = $"192.168.1.{i % 255 + 1}",
                Status = "Online",
                LastSync = DateTime.Now.AddHours(-i),
                PendingUpdates = i % 10,
                OsVersion = "Windows Server 2022"
            });
        }
        return computers;
    }

    private static List<UpdateInfo> CreateMockUpdates(int count)
    {
        var updates = new List<UpdateInfo>(count);
        var classifications = new[] { "Critical", "Security", "Definition", "Updates" };

        for (int i = 0; i < count; i++)
        {
            updates.Add(new UpdateInfo
            {
                KbNumber = $"KB{i + 500000}",
                Title = $"Update {i + 1}",
                Classification = classifications[i % classifications.Length],
                ApprovalStatus = "Approved",
                ApprovalDate = DateTime.Now.AddDays(-i % 30),
                ReleasedDate = DateTime.Now.AddDays(-(i % 30 + 1))
            });
        }
        return updates;
    }

    #endregion
}
```

### 5. Run Coverage Report

Generate coverage report to verify 80%+ coverage:

```bash
dotnet test src/WsusManager.Tests/WsusManager.Tests.csproj \
  --collect:"XPlat Code Coverage" \
  --results-directory TestResults \
  -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover

# Generate HTML report
reportgenerator -reports:TestResults/**/coverage.opencover.xml \
  -targetdir:TestResults/CoverageReport \
  -reporttypes:Html
```

## Implementation Notes

### Test Organization

- **Structural tests:** Verify XAML structure (KeyboardNavigationTests)
- **Unit tests:** Test business logic in isolation (SettingsPersistenceTests, CsvExportServiceTests)
- **ViewModel tests:** Test MVVM commands and properties (DataFilteringTests)
- **Integration tests:** Test interactions between components (future phase)

### Mock Dependencies

Use Moq for mocking services:
```csharp
var mockFileService = new Mock<IFileService>();
mockFileService.Setup(f => f.FileExists(It.IsAny<string>())).Returns(true);
```

### Test Data Factories

Create reusable factory methods for test data:
- `CreateMockComputers(count)`
- `CreateMockUpdates(count)`
- `CreateMockSettings()`

### Coverage Quality Gate

Set coverage threshold in `coverlet.runsettings`:
```xml
<Rule>
    <Match>
        <ModuleFilters>WsusManager.*</ModuleFilters>
    </Match>
    <Threshold>80</Threshold>
    <ThresholdStatistic>line</ThresholdStatistic>
</Rule>
```

## Testing Notes

### Regression Prevention

Run all existing tests to verify no regressions:
```bash
dotnet test src/WsusManager.Tests --verbosity normal
```

Expected: All 544+ existing tests still pass.

### Test Naming Convention

Follow `{MethodUnderTest}_Should_{ExpectedBehavior}` pattern:
- `ExportComputersAsync_ShouldCreateCsvFile`
- `ComputerStatusFilter_Online_ShowsOnlyOnline`
- `ResetToDefaultsAsync_ShouldRestoreAllDefaults`

### Assertion Pattern

Use Assert.Single, Assert.All, Assert.Contains for readable tests:
```csharp
Assert.Single(result); // Exactly one item
Assert.All(items, item => Assert.NotNull(item)); // All items pass
Assert.Contains("substring", text); // String contains
```

## Related Files

- `26-*.PLAN.md` — Keyboard and accessibility implementation
- `28-*.PLAN.md` — Settings expansion implementation
- `29-*.PLAN.md` — Data filtering implementation
- `30-*.PLAN.md` — CSV export implementation
- `.github/workflows/build-csharp.yml` — CI test coverage configuration

---

_Requirement: Test coverage for v4.5 features (Phases 26, 28, 29, 30)_
_Phase: 31-testing-documentation_
