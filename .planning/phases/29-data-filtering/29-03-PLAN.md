---
phase: 29-data-filtering
plan: 03
type: execute
wave: 1
depends_on:
  - 29-01
  - 29-02
files_modified:
  - src/WsusManager.App/ViewModels/MainViewModel.cs
  - src/WsusManager.Core/Services/DashboardService.cs
  - src/WsusManager.Core/Services/IDashboardService.cs
  - src/WsusManager.Tests/Services/DashboardServiceTests.cs
  - src/WsusManager.Tests/ViewModels/MainViewModelTests.cs
autonomous: true
requirements:
  - DAT-04

must_haves:
  truths:
    - "LoadComputersAsync populates FilteredComputers from WSUS API or mock data"
    - "LoadUpdatesAsync populates FilteredUpdates from DashboardService"
    - "Filters apply immediately after data loading (ApplyComputerFilters, ApplyUpdateFilters called)"
    - "Filters are persisted to AppSettings when changed (no manual save needed)"
    - "Filters restore on application startup from saved AppSettings"
    - "Empty state shows when no items match current filters"
    - "Filter count text updates correctly (e.g., '15 of 200 computers visible')"
    - "Clear filters button resets all filters and reapplies with 'All' values"
  artifacts:
    - path: "src/WsusManager.Core/Services/IDashboardService.cs"
      provides: "GetComputersAsync and GetUpdatesAsync methods"
      contains: "GetComputersAsync, GetUpdatesAsync"
    - path: "src/WsusManager.Core/Services/DashboardService.cs"
      provides: "Implementation of computer and update data retrieval"
      contains: "GetComputersAsync, GetUpdatesAsync with mock data or WSUS API calls"
    - path: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      provides: "LoadComputersAsync and LoadUpdatesAsync implementations"
      contains: "LoadComputersAsync, LoadUpdatesAsync with filter application"
  key_links:
    - from: "LoadComputersAsync"
      to: "DashboardService.GetComputersAsync"
      via: "await _dashboardService.GetComputersAsync(ct)"
      pattern: "service call"
    - from: "LoadUpdatesAsync"
      to: "DashboardService.GetUpdatesAsync"
      via: "await _dashboardService.GetUpdatesAsync(ct)"
      pattern: "service call"
    - from: "Filter changes"
      to: "AppSettings"
      via: "_settingsService.UpdateSettings()"
      pattern: "settings persistence"
---

<objective>
Implement data loading for Computers and Updates panels, connect filter persistence to actual data, and ensure filters apply correctly after loading. This plan completes the filtering feature by providing real data (mock or WSUS API) and ensuring filter persistence works end-to-end.

Purpose: The filter UI from plans 29-01 and 29-02 needs actual data to be useful. LoadComputersAsync and LoadUpdatesAsync populate the collections, and filters are reapplied after loading. Filter persistence ensures users' filter choices survive application restarts.

Output: Working LoadComputersAsync and LoadUpdatesAsync methods, DashboardService with GetComputersAsync/GetUpdatesAsync, mock data for testing, complete filter persistence flow, and comprehensive unit tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/29-data-filtering/29-CONTEXT.md
@.planning/phases/29-data-filtering/29-01-PLAN.md
@.planning/phases/29-data-filtering/29-02-PLAN.md
@src/WsusManager.Core/Services/IDashboardService.cs
@src/WsusManager.Core/Services/DashboardService.cs
@src/WsusManager.App/ViewModels/MainViewModel.cs
</context>

<tasks>

<task type="auto">
  <name>Add GetComputersAsync and GetUpdatesAsync to IDashboardService</name>
  <files>src/WsusManager.Core/Services/IDashboardService.cs</files>
  <action>
    Add methods to src/WsusManager.Core/Services/IDashboardService.cs:

    ```csharp
    /// <summary>
    /// Gets a list of all computers from the WSUS server.
    /// </summary>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>Collection of computer information with hostname, IP, status, last sync, pending updates, and OS version.</returns>
    Task<IReadOnlyList<ComputerInfo>> GetComputersAsync(CancellationToken ct = default);

    /// <summary>
    /// Gets a list of all updates from the WSUS database.
    /// </summary>
    /// <param name="ct">Cancellation token for async operation.</param>
    /// <returns>Collection of update information with ID, title, KB article, classification, approval date, and approval status.</returns>
    Task<IReadOnlyList<UpdateInfo>> GetUpdatesAsync(CancellationToken ct = default);
    ```

    Note: ComputerInfo is defined in MainViewModel.cs. For proper layering, we should move it to Core.Models. However, to minimize changes in this phase, we'll reference it from the ViewModel namespace.

    Add using statement if needed:
    ```csharp
    using WsusManager.App.ViewModels;
    ```

    DO NOT: Add filter parameters to these methods - filtering is handled in the ViewModel via CollectionView
  </action>
  <verify>
    dotnet build src/WsusManager.Core succeeds
  </verify>
  <done>
    IDashboardService.cs has GetComputersAsync and GetUpdatesAsync method signatures with XML documentation and CancellationToken parameter
  </done>
</task>

<task type="auto">
  <name>Implement GetComputersAsync and GetUpdatesAsync in DashboardService</name>
  <files>src/WsusManager.Core/Services/DashboardService.cs</files>
  <action>
    Implement the methods in src/WsusManager.Core/Services/DashboardService.cs:

    ```csharp
    public async Task<IReadOnlyList<ComputerInfo>> GetComputersAsync(CancellationToken ct = default)
    {
        // Phase 29: Return mock data for UI testing
        // Future: Query WSUS API for real computer list
        await Task.Delay(50, ct).ConfigureAwait(false); // Simulate network delay

        var now = DateTime.UtcNow;
        return new List<ComputerInfo>
        {
            new("LAB-PC001", "192.168.1.10", "Online", now.AddMinutes(-5), 0, "Windows 11 Pro"),
            new("LAB-PC002", "192.168.1.11", "Online", now.AddMinutes(-10), 3, "Windows 10 Pro"),
            new("LAB-PC003", "192.168.1.12", "Offline", now.AddHours(-2), 5, "Windows 10 Pro"),
            new("LAB-SRV001", "192.168.1.20", "Online", now.AddMinutes(-15), 0, "Windows Server 2022"),
            new("LAB-SRV002", "192.168.1.21", "Error", now.AddHours(-8), 12, "Windows Server 2019"),
            new("HR-PC001", "192.168.2.10", "Online", now.AddMinutes(-30), 1, "Windows 11 Pro"),
            new("HR-PC002", "192.168.2.11", "Offline", now.AddDays(-1), 0, "Windows 10 Pro"),
            new("FIN-PC001", "192.168.3.10", "Online", now.AddMinutes(-20), 0, "Windows 11 Pro"),
            new("FIN-PC002", "192.168.3.11", "Online", now.AddMinutes(-45), 7, "Windows 10 Pro"),
            new("DEV-PC001", "192.168.4.10", "Error", now.AddHours(-4), 2, "Windows 11 Pro"),
        };
    }

    public async Task<IReadOnlyList<UpdateInfo>> GetUpdatesAsync(CancellationToken ct = default)
    {
        // Phase 29: Return mock data for UI testing
        // Future: Query SUSDB for real update list
        await Task.Delay(50, ct).ConfigureAwait(false); // Simulate database query

        var now = DateTime.UtcNow;
        return new List<UpdateInfo>
        {
            new(Guid.NewGuid(), "KB5034441", "Security Update for Windows 11", "Security Updates", now.AddDays(-5), true, false),
            new(Guid.NewGuid(), "KB5034439", "Cumulative Update for Windows 11", "Critical Updates", now.AddDays(-5), true, false),
            new(Guid.NewGuid(), "KB5034442", "Security Update for .NET Framework 3.5", "Security Updates", now.AddDays(-3), true, false),
            new(Guid.NewGuid(), "KB5034443", "Security Update for Microsoft Defender", "Definition Updates", now.AddDays(-1), true, false),
            new(Guid.NewGuid(), "KB5034444", "Cumulative Update for Windows 10", "Critical Updates", now.AddDays(-7), true, false),
            new(Guid.NewGuid(), "KB5034445", "Security Update for Windows Server 2022", "Security Updates", now.AddDays(-4), false, false),
            new(Guid.NewGuid(), "KB5034446", "Update for Windows 11", "Updates", now.AddDays(-2), false, false),
            new(Guid.NewGuid(), "KB5034447", "Definition Update for Windows Defender", "Definition Updates", now.AddHours(-12), true, false),
            new(Guid.NewGuid(), "KB5034448", "Security Update for Microsoft Office", "Security Updates", now.AddDays(-6), false, false),
            new(Guid.NewGuid(), "KB5034449", "Critical Update for Windows Server 2019", "Critical Updates", now.AddDays(-10), true, false),
            new(Guid.NewGuid(), "KB5034450", "Cumulative Update for .NET Framework", "Updates", now.AddDays(-8), false, true), // Declined
            new(Guid.NewGuid(), "KB5034451", "Security Update for Windows 10", "Security Updates", now.AddDays(-9), false, false),
        };
    }
    ```

    Add using statement if needed:
    ```csharp
    using WsusManager.App.ViewModels;
    ```

    DO NOT: Query actual WSUS API or database in this phase - use mock data
  </action>
  <verify>
    dotnet build src/WsusManager.Core succeeds
  </verify>
  <done>
    DashboardService.cs has GetComputersAsync returning 10 mock ComputerInfo records (various statuses: Online, Offline, Error) and GetUpdatesAsync returning 12 mock UpdateInfo records (various classifications and approval statuses). Both methods simulate async delay and return IReadOnlyList<T>.
  </done>
</task>

<task type="auto">
  <name>Implement LoadComputersAsync and LoadUpdatesAsync in MainViewModel</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Replace the placeholder LoadComputersAsync and LoadUpdatesAsync methods in MainViewModel.cs:

    ```csharp
    /// <summary>
    /// Loads computers into FilteredComputers collection and applies current filters.
    /// Called when user navigates to Computers panel or dashboard refreshes.
    /// </summary>
    public async Task LoadComputersAsync(CancellationToken ct = default)
    {
        try
        {
            _logService?.LogDebug("Loading computers...");

            var computers = await _dashboardService.GetComputersAsync(ct);

            FilteredComputers.Clear();
            foreach (var computer in computers)
            {
                FilteredComputers.Add(computer);
            }

            // Apply any active filters after loading
            ApplyComputerFilters();

            _logService?.LogInfo($"Loaded {FilteredComputers.Count} computers");
        }
        catch (OperationCanceledException)
        {
            _logService?.LogWarning("Computer loading cancelled");
            throw;
        }
        catch (Exception ex)
        {
            _logService?.LogError($"Failed to load computers: {ex.Message}");
            FilteredComputers.Clear();
        }
        finally
        {
            OnPropertyChanged(nameof(ComputerVisibleCount));
            OnPropertyChanged(nameof(ComputerFilterCountText));
        }
    }

    /// <summary>
    /// Loads updates into FilteredUpdates collection and applies current filters.
    /// Called when user navigates to Updates panel or dashboard refreshes.
    /// </summary>
    public async Task LoadUpdatesAsync(CancellationToken ct = default)
    {
        try
        {
            _logService?.LogDebug("Loading updates...");

            var updates = await _dashboardService.GetUpdatesAsync(ct);

            FilteredUpdates.Clear();
            foreach (var update in updates)
            {
                FilteredUpdates.Add(update);
            }

            // Apply any active filters after loading
            ApplyUpdateFilters();

            _logService?.LogInfo($"Loaded {FilteredUpdates.Count} updates");
        }
        catch (OperationCanceledException)
        {
            _logService?.LogWarning("Update loading cancelled");
            throw;
        }
        catch (Exception ex)
        {
            _logService?.LogError($"Failed to load updates: {ex.Message}");
            FilteredUpdates.Clear();
        }
        finally
        {
            OnPropertyChanged(nameof(UpdateVisibleCount));
            OnPropertyChanged(nameof(UpdateFilterCountText));
        }
    }
    ```

    DO NOT: Call these methods automatically in the constructor - they should be called on-demand when navigating to the Computers/Updates panel
  </action>
  <verify>
    dotnet build src/WsusManager.App succeeds
  </verify>
  <done>
    MainViewModel.cs has LoadComputersAsync and LoadUpdatesAsync implementations that call DashboardService, clear collections, populate with data, call ApplyComputerFilters/ApplyUpdateFilters, log results, handle exceptions, and update count properties.
  </done>
</task>

<task type="auto">
  <name>Add navigation panel entries for Computers and Updates</name>
  <files>src/WsusManager.App/Views/MainWindow.xaml</files>
  <action>
    Add navigation buttons to the sidebar in MainWindow.xaml. Insert after the Client Tools section:

    ```xml
    <!-- DATA Category -->
    <TextBlock DockPanel.Dock="Top" Text="DATA" Style="{StaticResource CategoryLabel}"/>
    <Button DockPanel.Dock="Top" Content="Computers"
            ToolTip="View and filter computer list"
            x:Name="BtnComputers"
            automation:AutomationProperties.AutomationId="ComputersButton"
            Command="{Binding NavigateCommand}" CommandParameter="Computers">
        <Button.Style>
            <Style TargetType="Button" BasedOn="{StaticResource NavBtn}">
                <Style.Triggers>
                    <DataTrigger Binding="{Binding CurrentPanel}" Value="Computers">
                        <Setter Property="Background" Value="{DynamicResource NavActiveBackground}"/>
                        <Setter Property="BorderBrush" Value="{DynamicResource AccentBrush}"/>
                        <Setter Property="BorderThickness" Value="3,0,0,0"/>
                        <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </Button.Style>
    </Button>
    <Button DockPanel.Dock="Top" Content="Updates"
            ToolTip="View and filter update list"
            x:Name="BtnUpdates"
            automation:AutomationProperties.AutomationId="UpdatesButton"
            Command="{Binding NavigateCommand}" CommandParameter="Updates">
        <Button.Style>
            <Style TargetType="Button" BasedOn="{StaticResource NavBtn}">
                <Style.Triggers>
                    <DataTrigger Binding="{Binding CurrentPanel}" Value="Updates">
                        <Setter Property="Background" Value="{DynamicResource NavActiveBackground}"/>
                        <Setter Property="BorderBrush" Value="{DynamicResource AccentBrush}"/>
                        <Setter Property="BorderThickness" Value="3,0,0,0"/>
                        <Setter Property="Foreground" Value="{DynamicResource TextPrimary}"/>
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </Button.Style>
    </Button>
    ```

    Also update the Navigate method in MainViewModel.cs to handle "Computers" and "Updates" parameters:

    ```csharp
    "Computers" => "Computers",
    "Updates" => "Updates",
    ```

    And add auto-loading when navigating to these panels:

    ```csharp
    [RelayCommand]
    private async Task Navigate(string panel)
    {
        // ... existing code ...

        // Load data when navigating to data panels
        if (string.Equals(panel, "Computers", StringComparison.Ordinal) &&
            FilteredComputers.Count == 0)
        {
            await LoadComputersAsync();
        }
        else if (string.Equals(panel, "Updates", StringComparison.Ordinal) &&
                 FilteredUpdates.Count == 0)
        {
            await LoadUpdatesAsync();
        }

        OnPropertyChanged(nameof(IsComputersPanelVisible));
        OnPropertyChanged(nameof(IsUpdatesPanelVisible));
        // ... rest of method ...
    }
    ```

    DO NOT: Load data every time - only load once and cache (check if collection is empty)
  </action>
  <verify>
    dotnet build src/WsusManager.App succeeds
    MainWindow.xaml has DATA section with Computers and Updates navigation buttons
  </verify>
  <done>
    MainWindow.xaml sidebar has DATA category with Computers and Updates buttons. MainViewModel Navigate command handles "Computers" and "Updates" parameters, auto-loads data on first navigation (checks if collection is empty), and updates visibility properties.
  </done>
</task>

<task type="auto">
  <name>Add unit tests for data loading and filtering</name>
  <files>
    src/WsusManager.Tests/Services/DashboardServiceTests.cs
    src/WsusManager.Tests/ViewModels/MainViewModelTests.cs
  </files>
  <action>
    **Step 6a: Add DashboardService tests**

    Add to src/WsusManager.Tests/Services/DashboardServiceTests.cs:

    ```csharp
    [Fact]
    public async Task GetComputersAsync_ReturnsComputerInfoList()
    {
        // Arrange
        var dashboardService = _serviceProvider.GetRequiredService<IDashboardService>();

        // Act
        var result = await dashboardService.GetComputersAsync();

        // Assert
        Assert.NotNull(result);
        Assert.NotEmpty(result);
        Assert.All(result, computer =>
        {
            Assert.NotNull(computer.Hostname);
            Assert.NotNull(computer.IpAddress);
            Assert.NotNull(computer.Status);
            Assert.NotNull(computer.OsVersion);
        });
    }

    [Fact]
    public async Task GetUpdatesAsync_ReturnsUpdateInfoList()
    {
        // Arrange
        var dashboardService = _serviceProvider.GetRequiredService<IDashboardService>();

        // Act
        var result = await dashboardService.GetUpdatesAsync();

        // Assert
        Assert.NotNull(result);
        Assert.NotEmpty(result);
        Assert.All(result, update =>
        {
            Assert.NotEqual(Guid.Empty, update.UpdateId);
            Assert.NotNull(update.Title);
            Assert.NotNull(update.Classification);
        });
    }

    [Fact]
    public async Task GetComputersAsync_WhenCancelled_ThrowsOperationCanceledException()
    {
        // Arrange
        var dashboardService = _serviceProvider.GetRequiredService<IDashboardService>();
        var cts = new CancellationTokenSource();
        cts.Cancel();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => dashboardService.GetComputersAsync(cts.Token));
    }
    ```

    **Step 6b: Add MainViewModel data loading tests**

    Add to src/WsusManager.Tests/ViewModels/MainViewModelTests.cs:

    ```csharp
    [Fact]
    public async Task LoadComputersAsync_PopulatesFilteredComputers()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();

        // Act
        await viewModel.LoadComputersAsync();

        // Assert
        Assert.NotEmpty(viewModel.FilteredComputers);
        Assert.Equal(10, viewModel.FilteredComputers.Count); // Mock data has 10 computers
    }

    [Fact]
    public async Task LoadUpdatesAsync_PopulatesFilteredUpdates()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();

        // Act
        await viewModel.LoadUpdatesAsync();

        // Assert
        Assert.NotEmpty(viewModel.FilteredUpdates);
        Assert.Equal(12, viewModel.FilteredUpdates.Count); // Mock data has 12 updates
    }

    [Fact]
    public async Task LoadComputersAsync_AppliesActiveFilters()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();
        viewModel.ComputerStatusFilter = "Online";

        // Act
        await viewModel.LoadComputersAsync();

        // Assert
        var onlineCount = viewModel.FilteredComputers.Count(c =>
            string.Equals(c.Status, "Online", StringComparison.OrdinalIgnoreCase));
        Assert.Equal(onlineCount, viewModel.FilteredComputers.Count);
    }

    [Fact]
    public async Task LoadUpdatesAsync_AppliesActiveFilters()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();
        viewModel.UpdateApprovalFilter = "Approved";

        // Act
        await viewModel.LoadUpdatesAsync();

        // Assert
        Assert.All(viewModel.FilteredUpdates, u => Assert.True(u.IsApproved));
    }

    [Fact]
    public async Task NavigateToComputers_LoadsDataOnFirstVisit()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();
        Assert.Empty(viewModel.FilteredComputers);

        // Act
        await viewModel.NavigateCommand.ExecuteAsync("Computers");

        // Assert
        Assert.Equal("Computers", viewModel.CurrentPanel);
        Assert.NotEmpty(viewModel.FilteredComputers);
    }

    [Fact]
    public async Task NavigateToUpdates_LoadsDataOnFirstVisit()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();
        Assert.Empty(viewModel.FilteredUpdates);

        // Act
        await viewModel.NavigateCommand.ExecuteAsync("Updates");

        // Assert
        Assert.Equal("Updates", viewModel.CurrentPanel);
        Assert.NotEmpty(viewModel.FilteredUpdates);
    }

    [Fact]
    public async Task LoadComputersAsync_WhenCancelled_DoesNotCrash()
    {
        // Arrange
        var viewModel = _serviceProvider.GetRequiredService<MainViewModel>();
        var cts = new CancellationTokenSource();
        cts.Cancel();

        // Act & Assert
        await Assert.ThrowsAsync<OperationCanceledException>(
            () => viewModel.LoadComputersAsync(cts.Token));
    }
    ```

    DO NOT: Test real WSUS API - only mock data behavior
  </action>
  <verify>
    dotnet test src/WsusManager.Tests passes all tests
  </verify>
  <done>
    DashboardServiceTests.cs has 3 new tests: GetComputersAsync_ReturnsComputerInfoList, GetUpdatesAsync_ReturnsUpdateInfoList, GetComputersAsync_WhenCancelled_ThrowsOperationCanceledException. MainViewModelTests.cs has 7 new tests: LoadComputersAsync_PopulatesFilteredComputers, LoadUpdatesAsync_PopulatesFilteredUpdates, LoadComputersAsync_AppliesActiveFilters, LoadUpdatesAsync_AppliesActiveFilters, NavigateToComputers_LoadsDataOnFirstVisit, NavigateToUpdates_LoadsDataOnFirstVisit, LoadComputersAsync_WhenCancelled_DoesNotCrash. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Update ROADMAP.md to mark Phase 29 plans as complete</name>
  <files>.planning/ROADMAP.md</files>
  <action>
    Update .planning/ROADMAP.md to change Phase 29 status:

    Find this line:
    ```
    | 29. Data Filtering | v4.5 | 0/3 | Not started | - |
    ```

    Replace with:
    ```
    | 29. Data Filtering | v4.5 | 3/3 | Complete | 2026-02-21 |
    ```

    Also update the Phase 29 section plans list:

    Find:
    ```
    **Plans:** TBD
    ```

    Replace with:
    ```
    **Plans:** 3/3 complete
    - [x] 29-01-PLAN.md — Computers panel filter UI (DAT-01) (2026-02-21)
    - [x] 29-02-PLAN.md — Updates panel filter UI (DAT-02, DAT-03) (2026-02-21)
    - [x] 29-03-PLAN.md — Data loading and filter persistence (DAT-04) (2026-02-21)
    ```

    DO NOT: Change other phases
  </action>
  <verify>
    .planning/ROADMAP.md shows Phase 29 as 3/3 complete with 2026-02-21 date
  </verify>
  <done>
    ROADMAP.md updated to show Phase 29 as complete (3/3 plans) with completion date 2026-02-21
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: dotnet build src/WsusManager.App
2. Build succeeds: dotnet build src/WsusManager.Core
3. Tests pass: dotnet test src/WsusManager.Tests
4. IDashboardService has GetComputersAsync and GetUpdatesAsync methods
5. DashboardService implements GetComputersAsync (returns 10 mock computers) and GetUpdatesAsync (returns 12 mock updates)
6. MainViewModel LoadComputersAsync calls DashboardService, populates FilteredComputers, calls ApplyComputerFilters, handles exceptions
7. MainViewModel LoadUpdatesAsync calls DashboardService, populates FilteredUpdates, calls ApplyUpdateFilters, handles exceptions
8. MainWindow.xaml has DATA category with Computers and Updates navigation buttons
9. Navigate command loads data on first visit to Computers/Updates panels (checks if collection is empty)
10. DashboardServiceTests has 3 new tests for GetComputersAsync and GetUpdatesAsync
11. MainViewModelTests has 7 new tests for LoadComputersAsync, LoadUpdatesAsync, and Navigate behavior
12. All filters persist to AppSettings and restore on startup
13. Filters apply correctly after data loading
14. Empty state shows when no items match filters
15. Filter count text updates correctly
16. ROADMAP.md shows Phase 29 as complete (3/3 plans)
</verification>

<success_criteria>
DAT-04: Computers and Updates panels load real data (mock for Phase 29), filters persist to AppSettings and restore on startup, filters apply after data loading, clear filters button resets all filters, empty state shows when no items match, filter count text updates correctly.
</success_criteria>

<output>
After completion, create `.planning/phases/29-data-filtering/29-03-SUMMARY.md`
</output>
