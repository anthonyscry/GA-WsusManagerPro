# Phase 24-02: Developer Documentation (CONTRIBUTING.md)

**Created:** 2026-02-21
**Status:** Ready for implementation
**Requirements:** DOC-02

## Overview

CONTRIBUTING.md already exists and has good content for C# development. This plan updates it to ensure completeness and adds any missing sections (CI/CD documentation, release process details).

## Current State

CONTRIBUTING.md (as of 2026-02-21) includes:
- ✅ Prerequisites (.NET 8 SDK, Visual Studio)
- ✅ Build instructions (dotnet build)
- ✅ Test execution (dotnet test)
- ✅ Code style (.editorconfig, naming conventions)
- ✅ Static analysis (Roslyn analyzers, severity levels)
- ✅ Commit message format (conventional commits)
- ✅ Pull request process and checklist
- ✅ Project structure
- ✅ "Adding New Features" workflow

## Missing Content

Reviewing against DOC-02 requirement ("documents build, test, and commit conventions"):
- ⚠️ **CI/CD pipeline:** Mentioned but not documented (no workflow explanations)
- ⚠️ **Release process:** Not documented (covered by DOC-05, but should reference it)
- ⚠️ **PowerShell CLI scripts:** Not mentioned (still part of repo for Install/Restore/etc.)
- ⚠️ **Testing patterns:** No guidance on how to write tests (xUnit patterns, mocking)

## Success Criteria

1. New contributor can build, test, and submit changes following CONTRIBUTING.md alone
2. Build/test instructions work without additional documentation
3. Commit conventions are clear with examples
4. CI/CD pipeline is documented (what workflows exist, when they run)
5. Link to release process documentation (DOC-05)

## Implementation Plan

### Step 1: Add CI/CD Documentation Section

**Location:** After "Static Analysis" section, before "Commit Messages"

**Content to add:**
```markdown
## CI/CD Pipeline

WSUS Manager uses GitHub Actions for continuous integration and deployment.

### Workflows

**Build C# WSUS Manager** (`.github/workflows/build-csharp.yml`)
- **Triggers:** Push to main, pull request to main
- **Steps:** Restore, build, test, code coverage, publish
- **Artifacts:** Test results (TRX), coverage report (HTML), published EXE
- **Status:** Required for merge (PR checks must pass)

**Release C# WSUS Manager** (`.github/workflows/release-csharp.yml`)
- **Triggers:** Git tag push (e.g., `v4.4.0`)
- **Steps:** Build, test, create GitHub release, upload EXE as asset
- **Output:** Published release on GitHub Releases page
- **Manual:** Approve prerelease before publishing

**Build PowerShell GUI** (`.github/workflows/build-powershell.yml`)
- **Triggers:** Push to main (legacy PowerShell version)
- **Steps:** Pester tests, PSScriptAnalyzer, PS2EXE compilation
- **Status:** Maintained but superseded by C# version

### Running Workflows Locally

Before pushing, run the same commands CI executes:

```bash
# Build (Release configuration)
cd src
dotnet build --configuration Release

# Run tests with coverage
dotnet test --collect:"XPlat Code Coverage"

# Run tests with coverage report (requires ReportGenerator)
dotnet test --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover
reportgenerator -reports:**/coverage.cobertura.xml -targetdir:coverage.html
```

### Coverage Reports

Coverage is generated but not enforced (minimum threshold not set). View coverage in:
- **CI:** Download `coverage-report` artifact from Actions run
- **Local:** Open `coverage.html/index.html` after running with ReportGenerator
```

### Step 2: Add Testing Patterns Section

**Location:** After "Running Tests" section

**Content to add:**
```markdown
## Testing Guidelines

### Test Structure

Tests follow AAA pattern (Arrange, Act, Assert):

```csharp
[Fact]
public async Task ExecuteAsync_WithValidConfig_ReturnsSuccess()
{
    // Arrange
    var service = new HealthService(_mockLogger.Object, _mockConnection.Object);
    var config = new HealthCheckConfig { EnableDatabaseCheck = true };

    // Act
    var result = await service.CheckHealthAsync(config);

    // Assert
    Assert.True(result.IsHealthy);
    Assert.NotNull(result.DatabaseStatus);
}
```

### Naming Conventions

- Test method name: `MethodName_Scenario_ExpectedResult()`
- Async tests: Append `Async` suffix
- Parameterized tests: Use `[Theory]` with `[InlineData]`

### Mocking

Use Moq for mocking dependencies:

```csharp
// Arrange
var mockLogger = new Mock<ILogger<HealthService>>();
var mockConnection = new Mock<IDbConnection>();
mockConnection.Setup(x => x.OpenAsync(It.IsAny<CancellationToken>()))
             .Returns(Task.CompletedTask);

// Act
var service = new HealthService(mockLogger.Object, mockConnection.Object);

// Assert
mockConnection.Verify(x => x.OpenAsync(It.IsAny<CancellationToken>()), Times.Once);
```

### What to Test

- **Service layer:** All public methods, edge cases (null inputs, empty collections)
- **ViewModels:** Command execution, property change notifications, error handling
- **Validation:** Invalid inputs, boundary conditions, error messages
- **Infrastructure:** Log formatting, path validation, admin checks

### What NOT to Test

- Private/internal methods (test via public API)
- Third-party libraries (assume they work)
- UI layout (test ViewModel logic, not XAML)

### Test Data

Use `Theory` with `InlineData` for parameterized tests:

```csharp
[Theory]
[InlineData(null, false)]
[InlineData("", false)]
[InlineData("valid-host", true)]
public async Task ValidateHostname_ReturnsExpectedResult(string hostname, bool isValid)
{
    // Arrange
    var validator = new HostnameValidator();

    // Act
    var result = await validator.ValidateAsync(hostname);

    // Assert
    Assert.Equal(isValid, result.IsValid);
}
```
```

### Step 3: Add PowerShell CLI Scripts Section

**Location:** After "Project Structure" section

**Content to add:**
```markdown
## PowerShell Scripts

The C# application orchestrates PowerShell scripts for certain operations:

### PowerShell Scripts in Repository

- **Scripts/Invoke-WsusManagement.ps1** - Core WSUS operations (used by v3.x GUI)
- **Scripts/Invoke-WsusMonthlyMaintenance.ps1** - Online sync with profiles
- **Scripts/Install-WsusWithSqlExpress.ps1** - WSUS installation wizard
- **Scripts/Set-WsusHttps.ps1** - SSL certificate configuration
- **Scripts/Invoke-WsusClientCheckIn.ps1** - Client check-in trigger

### C# Integration

The C# app calls these scripts via `Process.Start()`:

```csharp
var psi = new ProcessStartInfo
{
    FileName = "powershell.exe",
    Arguments = $"-ExecutionPolicy Bypass -File \"{scriptPath}\" -{operation}",
    RedirectStandardOutput = true,
    RedirectStandardError = true,
    UseShellExecute = false,
    CreateNoWindow = true
};

using var process = Process.Start(psi);
// ... read output streams
```

### Testing PowerShell Scripts

PowerShell scripts have corresponding Pester tests in `Tests/`:

```powershell
# Run PowerShell tests
.\Tests\Run-PesterTests.ps1

# Or use Invoke-Pester directly
Invoke-Pester -Path .\Tests -Output Detailed
```

### Future: CLI in C#

A native C# CLI is planned for v4.5 to replace PowerShell scripts.
```

### Step 4: Update "Adding New Features" Section

**Current location:** Near end of file

**Enhancements to add:**
```markdown
## Adding New Features

### 1. Define the Interface

Create interface in `WsusManager.Core/Services/Interfaces/`:

```csharp
public interface IMyNewService
{
    Task<MyResult> ExecuteAsync(MyRequest request, CancellationToken cancellationToken);
}
```

### 2. Implement the Service

Create implementation in `WsusManager.Core/Services/`:

```csharp
internal class MyNewService : IMyNewService
{
    private readonly ILogger<MyNewService> _logger;
    private readonly IDependencyService _dependency;

    public MyNewService(ILogger<MyNewService> logger, IDependencyService dependency)
    {
        _logger = logger;
        _dependency = dependency;
    }

    public async Task<MyResult> ExecuteAsync(MyRequest request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Executing MyNewService");

        // ... implementation ...

        return new MyResult { Success = true };
    }
}
```

### 3. Register in DI Container

Add to `WsusManager.App/Services/ServiceCollectionExtensions.cs`:

```csharp
services.AddTransient<IMyNewService, MyNewService>();
```

### 4. Add Unit Tests

Create test file in `WsusManager.Tests/Services/`:

```csharp
public class MyNewServiceTests
{
    [Fact]
    public async Task ExecuteAsync_WithValidRequest_ReturnsSuccess()
    {
        // Arrange
        var mockLogger = new Mock<ILogger<MyNewService>>();
        var mockDependency = new Mock<IDependencyService>();
        var service = new MyNewService(mockLogger.Object, mockDependency.Object);
        var request = new MyRequest();

        // Act
        var result = await service.ExecuteAsync(request, CancellationToken.None);

        // Assert
        Assert.True(result.Success);
    }
}
```

### 5. Integrate in ViewModel (if UI-related)

Inject service into ViewModel:

```csharp
public class MainViewModel : ViewModelBase
{
    private readonly IMyNewService _myService;

    public MainViewModel(IMyNewService myService)
    {
        _myService = myService;
    }

    [RelayCommand(CanExecute = nameof(CanExecuteMyOperation))]
    private async Task RunMyOperationAsync()
    {
        await RunOperationAsync("My Operation", async () =>
        {
            var result = await _myService.ExecuteAsync(new MyRequest(), CancellationToken.None);
            return result.Success;
        });
    }
}
```

### 6. Add XML Documentation

Document public APIs with XML comments:

```csharp
/// <summary>
/// Executes the my new operation with the specified request.
/// </summary>
/// <param name="request">The request parameters.</param>
/// <param name="cancellationToken">Cancellation token for async operation.</param>
/// <returns>Result of the operation.</returns>
/// <exception cref="ArgumentNullException">Thrown when request is null.</exception>
/// <exception cref="OperationCanceledException">Thrown when operation is canceled.</exception>
public async Task<MyResult> ExecuteAsync(MyRequest request, CancellationToken cancellationToken)
{
    // ...
}
```
```

### Step 5: Add Release Process Reference

**Location:** After "Pull Requests" section

**Content to add:**
```markdown
## Release Process

WSUS Manager uses semantic versioning and automated releases. For detailed release procedures, see:

- **[docs/releases.md](../docs/releases.md)** - Complete release workflow (versioning, changelog, publish steps)
- **[CHANGELOG.md](../CHANGELOG.md)** - Version history and feature notes

**Quick summary:**
1. Update version in `src/WsusManager.App/WsusManager.App.csproj`
2. Update `CHANGELOG.md` with release notes
3. Commit and push to main branch
4. Create git tag: `git tag v4.4.0 && git push origin v4.4.0`
5. GitHub Actions creates release automatically
6. Approve prerelease and publish

For full details, refer to `docs/releases.md`.
```

### Step 6: Add "Getting Help" Section

**Location:** End of file, before "Thank you for contributing!"

**Content to add:**
```markdown
## Getting Help

### Documentation

- **[CLAUDE.md](CLAUDE.md)** - Legacy PowerShell development docs (for reference)
- **[docs/architecture.md](docs/architecture.md)** - C# architecture and design decisions
- **[docs/api/](docs/api/)** - API reference (generated via DocFX)

### Support Channels

- **GitHub Issues:** Report bugs or request features
- **GitHub Discussions:** Ask questions or start discussions
- **Wiki:** User guides and troubleshooting (to be migrated to docs/)

### Debugging Tips

- **Enable verbose logging:** Settings → Log Level → Verbose
- **Attach debugger:** Visual Studio → Debug → Attach to Process → WsusManager.exe
- **View logs:** `%APPDATA%\WsusManager\logs\`
- **Check diagnostics:** Run Diagnostics operation for health check

### Common Issues

| Issue | Solution |
|-------|----------|
| Build fails with "SDK not found" | Install .NET 8.0 SDK |
| Tests fail locally but pass in CI | Check test database settings, ensure SQL Express running |
| Can't attach debugger | Run as Administrator, check UAC settings |
| Analyzer warnings blocking build | Run `dotnet format` or fix manually |

For more troubleshooting, see README.md Troubleshooting section.
```

### Step 7: Review and Update Existing Content

**Review these sections for accuracy:**

1. **Prerequisites** - Ensure .NET 8 SDK link is current
2. **Build section** - Verify `dotnet build` commands work
3. **Code style** - Verify .editorconfig rules match actual config
4. **Static analysis** - Update analyzer list if new ones added
5. **Project structure** - Verify directory structure is current

**Changes needed (if any):**
- Update .NET SDK download link (if changed)
- Add/remove analyzers based on current `Directory.Build.props`
- Update project structure if new directories added

## Dependencies

None - this plan can execute independently.

## Verification

**Manual verification steps:**
1. New contributor follows CONTRIBUTING.md to build and test
2. Build instructions work without errors
3. CI/CD section accurately describes actual workflows
4. All code examples are syntactically correct
5. All links resolve (no broken file paths)

**Acceptance criteria:**
- [ ] CI/CD pipeline documented with workflow explanations
- [ ] Testing patterns section with examples
- [ ] PowerShell scripts section explaining C# integration
- [ ] Release process reference added
- [ ] Getting help section with support channels
- [ ] All code examples compile successfully
- [ ] No broken links (verified with `markdown-link-check` if available)

## Notes

- Keep CONTRIBUTING.md focused on "how to contribute", not "how to use" (that's README.md)
- Code examples should be real, compilable code (not pseudocode)
- Link to external docs (DocFX API, architecture docs) rather than duplicating
- Update CONTRIBUTING.md whenever CI/CD workflows change
- Keep commit examples simple - conventional commits are straightforward

---

*Plan: 24-02-PLAN.md*
*Phase: 24-documentation-generation*
*Created: 2026-02-21*
