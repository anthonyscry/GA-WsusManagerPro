# Phase 21-01: Code Refactoring & Async Audit - Plan

**Created:** 2026-02-21
**Status:** Ready for implementation

## Analysis Findings

### 1. Async/Audit Patterns (Priority: Low - Already Good)

**Finding:** The codebase already follows excellent async practices:
- All Core library methods use `ConfigureAwait(false)`
- All async methods accept `CancellationToken ct = default`
- No `.Result`, `.Wait()`, or `.GetAwaiter().GetResult()` anti-patterns found
- Cancellation tokens are properly propagated through call chains

**Action:** No changes required. The async patterns are already optimal.

### 2. High Complexity Methods (Priority: Medium)

**Finding:** No critical complexity issues detected:
- Largest method is `RunOperationAsync` (~90 lines) but it's well-structured
- Most service methods are focused and single-purpose
- Phase 19 static analysis already addressed complexity warnings

**Action:** Document current state, defer further refactoring until Phase 24 (Performance Optimization).

### 3. Duplicated Code Patterns (Priority: High - Recommended)

#### Pattern 1: WinRM Availability Check (4 occurrences)

**Location:** `ClientService.cs` - Lines 56-62, 121-127, 198-204, 264-270

```csharp
// Current pattern (repeated 4x):
progress.Report("[Step X/Y] Checking WinRM connectivity...");
if (!await _executor.TestWinRmAsync(hostname, ct).ConfigureAwait(false))
{
    var msg = BuildWinRmUnavailableMessage(hostname);
    progress.Report(msg);
    _log.Warning("Method: WinRM unavailable on {Hostname}", hostname);
    return OperationResult.Fail(msg);
}
progress.Report("[OK] WinRM is available.");
```

**Recommendation:** Extract to helper method `EnsureWinRmAvailableAsync`

**Complexity Reduction:** ~24 lines -> 6 lines (4 calls)

#### Pattern 2: Script Execution with Error Handling (4 occurrences)

**Location:** `ClientService.cs` - Lines 78-88, 144-153, 216-225, 285-294

```csharp
// Current pattern (repeated 4x):
var result = await _executor.ExecuteRemoteAsync(hostname, scriptBlock, progress, ct)
    .ConfigureAwait(false);

if (!result.Success)
{
    var msg = $"Operation failed on {hostname}: {result.Output}";
    _log.Warning("Method: failed on {Hostname}: {Output}", hostname, result.Output);
    return OperationResult.Fail(msg);
}
```

**Recommendation:** Extract to helper method `ExecuteRemoteScriptAsync`

**Complexity Reduction:** ~20 lines -> 4 lines (4 calls)

#### Pattern 3: Database Size Query (2 occurrences)

**Location:** `DeepCleanupService.cs` and `DatabaseBackupService.cs`

```csharp
// Duplicated in two files:
private async Task<double> GetDatabaseSizeGbAsync(string sqlInstance, CancellationToken ct)
{
    const string sql = "SELECT CAST(size * 8.0 / 1024 / 1024 AS DECIMAL(10,2)) FROM sys.database_files WHERE file_id = 1";
    var result = await _sqlService.ExecuteScalarAsync(sqlInstance, SusDb, sql, ct).ConfigureAwait(false);
    // ... parsing logic ...
}
```

**Recommendation:** Move to `ISqlService` as `GetDatabaseSizeAsync`

**Complexity Reduction:** ~10 lines per file -> 1 line

## Implementation Tasks

### Task 1: Extract WinRM Check Helper (21-REF-01)

**File:** `src/WsusManager.Core/Services/ClientService.cs`

**Changes:**
1. Add private method: `private async Task<OperationResult> EnsureWinRmAvailableAsync(string hostname, string operationName, IProgress<string> progress, CancellationToken ct)`
2. Replace 4 WinRM check blocks with calls to helper
3. Update logging to use operationName parameter

**Estimated Lines:** -18 (net reduction)

### Task 2: Extract Script Execution Helper (21-REF-02)

**File:** `src/WsusManager.Core/Services/ClientService.cs`

**Changes:**
1. Add private method: `private async Task<ProcessResult> ExecuteRemoteScriptAsync(string hostname, string scriptBlock, string operationName, IProgress<string>? progress, CancellationToken ct)`
2. Replace 4 ExecuteRemoteAsync blocks with calls to helper
3. Centralize error logging

**Estimated Lines:** -16 (net reduction)

### Task 3: Consolidate Database Size Query (21-REF-03)

**Files:**
- `src/WsusManager.Core/Services/DeepCleanupService.cs`
- `src/WsusManager.Core/Services/DatabaseBackupService.cs`
- `src/WsusManager.Core/Services/Interfaces/ISqlService.cs`
- `src/WsusManager.Core/Services/SqlService.cs`

**Changes:**
1. Add to `ISqlService`: `Task<double> GetDatabaseSizeAsync(string sqlInstance, string databaseName, CancellationToken ct)`
2. Implement in `SqlService`
3. Remove duplicate methods from `DeepCleanupService` and `DatabaseBackupService`

**Estimated Lines:** -10 (net reduction across 2 files)

## Quality Gates

### Before Implementation
- [ ] All tests pass (`dotnet test`)
- [ ] Build succeeds with no warnings
- [ ] Code coverage ≥70%

### After Implementation
- [ ] All tests pass
- [ ] No new analyzer warnings
- [ ] Manual test each refactored operation:
  - [ ] Cancel Stuck Jobs
  - [ ] Force Check-In
  - [ ] Test Connectivity
  - [ ] Run Diagnostics
- [ ] Code coverage maintained or improved

## Risk Assessment

**Low Risk:**
- Changes are purely internal refactoring
- No API surface changes
- Existing tests cover all affected methods

**Mitigation:**
- Run full test suite after each task
- Manual verification of client operations

## Success Criteria

1. **Code Reduction:** Minimum 40 lines removed (net)
2. **Complexity:** No increase in cyclomatic complexity
3. **Maintainability:** Duplicated patterns eliminated
4. **Test Coverage:** Maintained at ≥70%

## Deferred Work

The following items are intentionally deferred to future phases:

1. **MainViewModel Size (1379 lines)** - Defer to Phase 24 (Performance)
   - Consider splitting into multiple ViewModels
   - Extract operation handlers to separate classes

2. **HealthService Check Methods** - Defer to Phase 22 (Polish)
   - Each check method is similar but purposefully distinct
   - Consolidation may reduce clarity

3. **ConfigureAwait in App Layer** - No action needed
   - Current usage is correct for MVVM pattern
   - CommunityToolkit.Mvvm handles UI thread marshalling

---

**Next Step:** Implement Task 1 (Extract WinRM Check Helper)
