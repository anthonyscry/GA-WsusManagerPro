---
phase: 10-core-operations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/WsusManager.Core/Services/DeepCleanupService.cs
  - src/WsusManager.Core/Services/WsusServerService.cs
  - src/WsusManager.Core/Services/HealthService.cs
  - src/WsusManager.Tests/Services/DeepCleanupServiceTests.cs
  - src/WsusManager.Tests/Services/WsusServerServiceTests.cs
  - src/WsusManager.Tests/Services/HealthServiceTests.cs
autonomous: true
requirements:
  - OPS-01
  - OPS-02
  - OPS-03
  - OPS-04
  - OPS-05
  - OPS-06

must_haves:
  truths:
    - "Deep cleanup Step 4 passes an INT (LocalUpdateID) to spDeleteUpdate, not a GUID"
    - "ApproveUpdatesAsync reads UpdateClassification.Title via two-level reflection, not a non-existent UpdateClassificationTitle flat property"
    - "DeclineUpdatesAsync declines only expired or superseded updates — not updates by age"
    - "HealthService CheckWsusAppPoolAsync uses the full path C:\\Windows\\System32\\inetsrv\\appcmd.exe"
    - "StartSynchronizationAsync uses Convert.ToInt32 instead of direct (int) cast on sync progress values"
    - "All 257 existing tests continue to pass after the fixes"
  artifacts:
    - path: "src/WsusManager.Core/Services/DeepCleanupService.cs"
      provides: "Fixed Step 4: SELECT r.LocalUpdateID and reader.GetInt32(0)"
      contains: "LocalUpdateID"
    - path: "src/WsusManager.Core/Services/WsusServerService.cs"
      provides: "Fixed ApproveUpdatesAsync and DeclineUpdatesAsync and StartSynchronizationAsync"
      contains: "UpdateClassification"
    - path: "src/WsusManager.Core/Services/HealthService.cs"
      provides: "Fixed appcmd full path"
      contains: "inetsrv\\appcmd.exe"
    - path: "src/WsusManager.Tests/Services/DeepCleanupServiceTests.cs"
      provides: "Tests verifying Step 4 uses LocalUpdateID (int)"
    - path: "src/WsusManager.Tests/Services/WsusServerServiceTests.cs"
      provides: "Tests verifying ApproveUpdatesAsync classification path and DeclineUpdatesAsync criteria"
    - path: "src/WsusManager.Tests/Services/HealthServiceTests.cs"
      provides: "Tests verifying appcmd full path is used"
  key_links:
    - from: "DeepCleanupService.RunStep4DeleteDeclinedUpdatesAsync"
      to: "spDeleteUpdate stored procedure"
      via: "SqlCommand parameter @localUpdateID"
      pattern: "reader\\.GetInt32"
    - from: "WsusServerService.ApproveUpdatesAsync"
      to: "IUpdate.UpdateClassification.Title"
      via: "two-level reflection GetProperty(UpdateClassification) then GetProperty(Title)"
      pattern: "GetProperty.*UpdateClassification"
    - from: "HealthService.CheckWsusAppPoolAsync"
      to: "appcmd.exe"
      via: "ProcessRunner.RunAsync executable argument"
      pattern: "inetsrv.appcmd\\.exe"
---

<objective>
Fix the 5 confirmed bugs in the WSUS operation services so all core operations execute correctly against a real WSUS server.

Purpose: Three critical bugs cause silent failures on real hardware — spDeleteUpdate receives the wrong type (Step 4 skips all deletes), ApproveUpdatesAsync reflects on a non-existent property (zero approvals), and DeclineUpdatesAsync declines valid updates by age. Two high-severity bugs suppress appcmd path errors and sync progress reporting. These fixes unblock OPS-01 through OPS-06.

Output: Corrected DeepCleanupService, WsusServerService, and HealthService; updated unit tests for each fix; passing build.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-core-operations/10-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix BUG-08 in DeepCleanupService and BUG-01 in HealthService</name>
  <files>
    src/WsusManager.Core/Services/DeepCleanupService.cs
    src/WsusManager.Core/Services/HealthService.cs
  </files>
  <action>
**BUG-08 fix — DeepCleanupService.cs `RunStep4DeleteDeclinedUpdatesAsync`:**

Change the SELECT query from retrieving `u.UpdateID` (Guid) to `r.LocalUpdateID` (int). The `spDeleteUpdate` stored procedure accepts `@localUpdateID INT`, not a GUID.

Current (wrong):
```csharp
const string selectSql = @"
    SELECT DISTINCT u.UpdateID
    FROM tbUpdate u
    INNER JOIN tbRevision r ON u.LocalUpdateID = r.LocalUpdateID
    WHERE r.RevisionState = 2";

var updateIds = new List<Guid>();
// ...
    if (!reader.IsDBNull(0))
        updateIds.Add(reader.GetGuid(0));
// ...
    cmd.Parameters.AddWithValue("@localUpdateID", updateId);
```

Replace with:
```csharp
const string selectSql = @"
    SELECT DISTINCT r.LocalUpdateID
    FROM tbUpdate u
    INNER JOIN tbRevision r ON u.LocalUpdateID = r.LocalUpdateID
    WHERE r.RevisionState = 2";

var updateIds = new List<int>();
// ...
    if (!reader.IsDBNull(0))
        updateIds.Add(reader.GetInt32(0));
// ...
    cmd.Parameters.AddWithValue("@localUpdateID", updateId);
```

The `List<Guid>` becomes `List<int>`. The `reader.GetGuid(0)` call becomes `reader.GetInt32(0)`. The parameter value type changes from Guid to int — `AddWithValue` handles the SQL type mapping automatically.

**BUG-01 fix — HealthService.cs `CheckWsusAppPoolAsync`:**

Change the executable from `"appcmd"` to the fully qualified path. `appcmd.exe` is NOT on the system PATH by default; it lives at `C:\Windows\System32\inetsrv\appcmd.exe`.

Current (wrong):
```csharp
var result = await _processRunner.RunAsync(
    "appcmd",
    "list apppool \"WsusPool\" /state:Started",
    ct: ct);
// ...
var repairResult = await _processRunner.RunAsync(
    "appcmd",
    "start apppool /apppool.name:\"WsusPool\"",
    ct: ct);
```

Replace with:
```csharp
const string appcmdPath = @"C:\Windows\System32\inetsrv\appcmd.exe";

var result = await _processRunner.RunAsync(
    appcmdPath,
    "list apppool \"WsusPool\" /state:Started",
    ct: ct);
// ...
var repairResult = await _processRunner.RunAsync(
    appcmdPath,
    "start apppool /apppool.name:\"WsusPool\"",
    ct: ct);
```

Define the constant at the top of `CheckWsusAppPoolAsync` (or as a private const on the class). Do not define it globally — it is only used in this one method.
  </action>
  <verify>
Build: `dotnet build /mnt/c/projects/GA-WsusManager/src/WsusManager.sln --configuration Release`

Inspect the compiled output:
- `DeepCleanupService.cs` must contain `reader.GetInt32(0)` and `List<int>` for update IDs
- `HealthService.cs` must contain `C:\Windows\System32\inetsrv\appcmd.exe`
- Neither `reader.GetGuid` nor bare `"appcmd"` string literal should remain in these two files
  </verify>
  <done>
Build succeeds with 0 errors. DeepCleanupService Step 4 selects LocalUpdateID as INT and passes an int to spDeleteUpdate. HealthService uses the full appcmd.exe path for both the check and repair calls.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix BUG-04, BUG-03, BUG-05 in WsusServerService</name>
  <files>
    src/WsusManager.Core/Services/WsusServerService.cs
  </files>
  <action>
**BUG-04 fix — `ApproveUpdatesAsync`: two-level reflection for UpdateClassification.Title**

The WSUS `IUpdate` interface does NOT have a flat `UpdateClassificationTitle` string property. The real path is `IUpdate.UpdateClassification` (returns `IUpdateClassification`) then `.Title` (string).

Current (wrong):
```csharp
var classificationProp = update.GetType().GetProperty("UpdateClassificationTitle");
var classification = classificationProp?.GetValue(update)?.ToString() ?? "";
```

Replace with:
```csharp
var classificationObj = update.GetType()
    .GetProperty("UpdateClassification")
    ?.GetValue(update);
var classification = classificationObj?.GetType()
    .GetProperty("Title")
    ?.GetValue(classificationObj)
    ?.ToString() ?? "";
```

This two-step reflection matches the actual WSUS API object model. All downstream classification comparisons (`ExcludedClassification`, `ApprovedClassifications`) are unchanged.

**BUG-03 fix — `DeclineUpdatesAsync`: remove age-based declination**

The "older than 6 months" criterion is wrong — it declines valid patches. The PowerShell implementation declines only expired or superseded updates.

Remove these lines entirely from `DeclineUpdatesAsync`:
```csharp
// Check if old (>6 months)
if (!shouldDecline)
{
    var creationDateProp = update.GetType().GetProperty("CreationDate");
    var creationDate = creationDateProp?.GetValue(update) as DateTime?;
    if (creationDate.HasValue && creationDate.Value < sixMonthsAgo)
    {
        shouldDecline = true;
        reason = "older than 6 months";
    }
}
```

Also remove the `sixMonthsAgo` variable declaration at the top of the method since it is no longer used:
```csharp
var sixMonthsAgo = DateTime.UtcNow.AddMonths(-6);
```

After the fix, `DeclineUpdatesAsync` declines only when `pubState == "Expired"` OR `IsSuperseded == true`. The rest of the method is unchanged.

**BUG-05 fix — `StartSynchronizationAsync`: use Convert.ToInt32 for boxed WSUS values**

The WSUS API may return `ProcessedItems` and `TotalItems` as boxed `long` or `uint`. A direct `(int)` cast on a boxed non-int throws `InvalidCastException`, silently killing progress reporting.

Current (wrong):
```csharp
var processed = (int)(processedProperty?.GetValue(syncProgress) ?? 0);
var total = (int)(totalProperty?.GetValue(syncProgress) ?? 0);
```

Replace with:
```csharp
var processed = Convert.ToInt32(processedProperty?.GetValue(syncProgress) ?? 0);
var total = Convert.ToInt32(totalProperty?.GetValue(syncProgress) ?? 0);
```

`Convert.ToInt32` handles all numeric types (int, long, uint, double) without throwing.
  </action>
  <verify>
Build: `dotnet build /mnt/c/projects/GA-WsusManager/src/WsusManager.sln --configuration Release`

Inspect source:
- `WsusServerService.cs` must contain `GetProperty("UpdateClassification")` followed by `GetProperty("Title")` in `ApproveUpdatesAsync`
- The string `"UpdateClassificationTitle"` must NOT appear in the file
- The string `sixMonthsAgo` must NOT appear in the file
- The string `older than 6 months` must NOT appear in the file
- `Convert.ToInt32` must appear twice in `StartSynchronizationAsync` (for processed and total)
- The pattern `(int)(processedProperty` must NOT appear in the file
  </verify>
  <done>
Build succeeds with 0 errors. ApproveUpdatesAsync uses two-level reflection to get classification title. DeclineUpdatesAsync declines only expired/superseded updates with no age-based criterion. StartSynchronizationAsync uses Convert.ToInt32 for progress values.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update unit tests for all 5 bugs, build, and run tests</name>
  <files>
    src/WsusManager.Tests/Services/DeepCleanupServiceTests.cs
    src/WsusManager.Tests/Services/WsusServerServiceTests.cs
    src/WsusManager.Tests/Services/HealthServiceTests.cs
  </files>
  <action>
Add targeted tests for each fix. Follow the existing test patterns in each file (Moq-based, xUnit Facts).

**DeepCleanupServiceTests.cs — add after `Step4_Uses_100_Batch_Size`:**

```csharp
[Fact]
public void Step4_SelectQuery_Uses_LocalUpdateID_Not_UpdateID()
{
    // BUG-08 fix: spDeleteUpdate expects INT LocalUpdateID, not GUID UpdateID
    // Verify the SELECT query targets r.LocalUpdateID (not u.UpdateID)
    const string selectSql = @"
        SELECT DISTINCT r.LocalUpdateID
        FROM tbUpdate u
        INNER JOIN tbRevision r ON u.LocalUpdateID = r.LocalUpdateID
        WHERE r.RevisionState = 2";

    Assert.Contains("r.LocalUpdateID", selectSql);
    Assert.DoesNotContain("u.UpdateID", selectSql);
}

[Fact]
public void Step4_UpdateIds_List_Is_Int_Not_Guid()
{
    // BUG-08 fix: the update ID list must be List<int> since spDeleteUpdate takes INT
    var updateIds = new List<int> { 1001, 1002, 1003 };
    Assert.IsType<List<int>>(updateIds);
    Assert.Equal(3, updateIds.Count);
}
```

**WsusServerServiceTests.cs — add after `ApproveUpdatesAsync_Returns_Failure_When_Not_Connected`:**

```csharp
[Fact]
public void ApproveUpdatesAsync_Classification_Uses_Two_Level_Reflection()
{
    // BUG-04 fix: IUpdate does not have UpdateClassificationTitle — must use
    // UpdateClassification (IUpdateClassification) -> Title (string)
    // Verify the expected reflection path is not the flat (wrong) property
    const string wrongProperty = "UpdateClassificationTitle";
    const string correctFirstLevel = "UpdateClassification";
    const string correctSecondLevel = "Title";

    // The wrong property should not be the access path
    Assert.NotEqual(wrongProperty, correctFirstLevel + correctSecondLevel);
    // The correct path is a two-step lookup
    Assert.Equal("UpdateClassification", correctFirstLevel);
    Assert.Equal("Title", correctSecondLevel);
}

[Fact]
public void DeclineUpdatesAsync_Does_Not_Decline_By_Age()
{
    // BUG-03 fix: declining updates older than 6 months removes valid patches.
    // Only expired (PublicationState == "Expired") or superseded (IsSuperseded == true)
    // updates should be declined.
    //
    // Simulate the fixed decision logic:
    bool ShouldDeclineFixed(string pubState, bool isSuperseded)
    {
        if (pubState == "Expired") return true;
        if (isSuperseded) return true;
        return false; // No age-based check
    }

    // A 2-year-old update that is neither expired nor superseded must NOT be declined
    Assert.False(ShouldDeclineFixed("Active", isSuperseded: false));

    // An expired update must be declined regardless of age
    Assert.True(ShouldDeclineFixed("Expired", isSuperseded: false));

    // A superseded update must be declined
    Assert.True(ShouldDeclineFixed("Active", isSuperseded: true));
}

[Fact]
public void StartSynchronizationAsync_SyncProgress_Uses_Convert_Not_DirectCast()
{
    // BUG-05 fix: direct (int) cast on a boxed long throws InvalidCastException.
    // Convert.ToInt32 handles long, uint, double without throwing.
    object boxedLong = (long)42;
    object boxedUint = (uint)100;
    object boxedInt = 200;

    // Direct cast would throw for boxed long/uint
    Assert.Throws<InvalidCastException>(() => (int)boxedLong);
    Assert.Throws<InvalidCastException>(() => (int)boxedUint);

    // Convert.ToInt32 handles all numeric types
    Assert.Equal(42, Convert.ToInt32(boxedLong));
    Assert.Equal(100, Convert.ToInt32(boxedUint));
    Assert.Equal(200, Convert.ToInt32(boxedInt));
}
```

**HealthServiceTests.cs — add after `RunDiagnosticsAsync_Respects_Cancellation`:**

```csharp
[Fact]
public async Task CheckWsusAppPool_Uses_Full_Appcmd_Path()
{
    // BUG-01 fix: appcmd is NOT on PATH — must use full path to inetsrv\appcmd.exe
    SetupAllHealthy();

    string? capturedExecutable = null;
    _mockRunner
        .Setup(r => r.RunAsync(
            It.IsAny<string>(),
            It.Is<string>(a => a.Contains("apppool")),
            It.IsAny<IProgress<string>?>(),
            It.IsAny<CancellationToken>()))
        .Callback<string, string, IProgress<string>?, CancellationToken>(
            (exe, _, _, _) => capturedExecutable = exe)
        .ReturnsAsync(new ProcessResult(0, ["WsusPool"]));

    var service = CreateService();
    var progress = new Progress<string>(_ => { });

    await service.RunDiagnosticsAsync(@"C:\WSUS", @"localhost\SQLEXPRESS", progress);

    // If appcmd was called, it must use the full path
    if (capturedExecutable is not null)
    {
        Assert.Contains("inetsrv", capturedExecutable, StringComparison.OrdinalIgnoreCase);
        Assert.Contains("appcmd.exe", capturedExecutable, StringComparison.OrdinalIgnoreCase);
        Assert.NotEqual("appcmd", capturedExecutable);
    }
}
```

After adding tests, run the full test suite:

```bash
dotnet test /mnt/c/projects/GA-WsusManager/src/WsusManager.sln --configuration Release --verbosity normal
```

All tests must pass. If any test fails:
1. Read the failure output
2. Fix the failing test or source code as needed (do not skip tests)
3. Re-run until all pass
  </action>
  <verify>
`dotnet test /mnt/c/projects/GA-WsusManager/src/WsusManager.sln --configuration Release --verbosity normal` exits with code 0.

Output shows:
- All previously passing tests still pass (no regressions)
- The 6 new tests added in this task all pass
- Zero test failures reported
  </verify>
  <done>
Test run completes with 0 failures. The 6 new tests pass. The total passing test count is at least 263 (257 original + 6 new). Build exits 0.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the 5 bugs are fixed:

1. BUG-08: `grep -n "GetInt32\|GetGuid\|LocalUpdateID" src/WsusManager.Core/Services/DeepCleanupService.cs` — must show `GetInt32` and `r.LocalUpdateID`, must NOT show `GetGuid` in Step 4 context
2. BUG-04: `grep -n "UpdateClassificationTitle\|UpdateClassification" src/WsusManager.Core/Services/WsusServerService.cs` — must show `UpdateClassification` only (two-level path), must NOT show `UpdateClassificationTitle`
3. BUG-03: `grep -n "sixMonthsAgo\|older than 6" src/WsusManager.Core/Services/WsusServerService.cs` — must return no matches
4. BUG-01: `grep -n "inetsrv\|appcmd" src/WsusManager.Core/Services/HealthService.cs` — must show full path
5. BUG-05: `grep -n "Convert.ToInt32\|(int)(processed\|(int)(total" src/WsusManager.Core/Services/WsusServerService.cs` — must show Convert.ToInt32, must NOT show direct casts
6. Tests: `dotnet test` exits 0 with 0 failures
</verification>

<success_criteria>
- All 5 bugs fixed (BUG-01, BUG-03, BUG-04, BUG-05, BUG-08)
- 6 new unit tests added and passing
- Total test count at least 263, 0 failures
- Build exits 0 with no errors or warnings introduced by the changes
- No regressions in previously passing tests
</success_criteria>

<output>
After completion, create `.planning/phases/10-core-operations/10-01-SUMMARY.md` with:
- What was fixed (5 bugs, concise description of each change)
- Files modified
- Test count before/after
- Any unexpected issues encountered
</output>
