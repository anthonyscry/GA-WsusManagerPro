---
phase: 18-test-coverage-reporting
plan: 03
type: execute
wave: 3
depends_on: ["18-02"]
files_modified:
  - src/WsusManager.Tests/Services/SqlServiceTests.cs
  - src/WsusManager.Tests/Services/WindowsServiceManagerTests.cs
  - src/WsusManager.Tests/Services/DatabaseOperationsServiceTests.cs
  - src/WsusManager.Tests/Services/WinRMServiceTests.cs
autonomous: true
requirements:
  - TEST-06
user_setup: []

must_haves:
  truths:
    - "SqlException caught and handled gracefully in database operations"
    - "IOException caught and handled for file I/O failures"
    - "WinRM exceptions caught and handled in remote operations"
    - "Service failure exceptions caught in service management"
    - "Coverage report shows exception paths are tested"
  artifacts:
    - path: "src/WsusManager.Tests/Services/*Tests.cs"
      provides: "Exception path tests for error handling"
      contains: "SqlException", "IOException", "Throws", "Setup.*Throws"
  key_links:
    - from: "Exception tests"
      to: "Production try-catch blocks"
      via: "Mock.Setup throws exception, test verifies catch behavior"
      pattern: "Setup.*Throws.*Exception"
    - from: "Test coverage"
      to: "Exception handler blocks"
      via: "Exception tests exercise catch blocks that normal flow doesn't reach"
      pattern: "catch.*\\(" in coverage highlighting
---

<objective>
Add tests for all exception handling paths (try-catch blocks) across the service layer. Focus on database operations, file I/O, Windows services, and WinRM remote operations where exceptions are caught and transformed into OperationResult or logged.

Purpose: Verify error handling code paths actually work and don't have unreachable catch blocks
Output: Complete exception path coverage with measurable coverage increase in error handling branches
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/18-test-coverage-reporting/18-CONTEXT.md
@.planning/phases/18-test-coverage-reporting/18-RESEARCH.md
@.planning/phases/18-test-coverage-reporting/18-02-SUMMARY.md
@src/WsusManager.Core/Services/SqlService.cs
@src/WsusManager.Core/Services/DatabaseOperationsService.cs
@src/WsusManager.Core/Services/WinRMService.cs
@src/WsusManager.Tests/Services/HealthServiceTests.cs
</context>

<tasks>

<task type="auto">
  <name>Audit production code for exception handling paths</name>
  <files>
    src/WsusManager.Core/Services/SqlService.cs
    src/WsusManager.Core/Services/DatabaseOperationsService.cs
    src/WsusManager.Core/Services/WindowsServiceManager.cs
    src/WsusManager.Core/Services/WinRMService.cs
  </files>
  <action>
Search all service files for exception handling patterns using grep:

1. Find all try-catch blocks:
```bash
grep -n "catch (" src/WsusManager.Core/Services/*.cs
```

2. For each catch block, identify:
   - Exception type caught (SqlException, IOException, InvalidOperationException, etc.)
   - Method containing the catch block
   - What the catch does (returns OperationResult.Fail, logs, rethrows)

3. Create an exception path audit list documenting:
```
EXCEPTION PATH AUDIT (Phase 18-03):
SqlService.cs:
  [ ] ExecuteQueryAsync catches SqlException → returns Fail result
  [ ] OpenConnectionAsync catches SqlException → logs and returns Fail

DatabaseOperationsService.cs:
  [ ] RestoreDatabaseAsync catches IOException → returns Fail result
  [ ] BackupDatabaseAsync catches SqlException → returns Fail result

WindowsServiceManager.cs:
  [ ] GetStatusAsync catches ServiceNotFoundException → returns NotFound result
  [ ] StartServiceAsync catches InvalidOperationException → returns Fail result

WinRMServiceTests.cs:
  [ ] RunCommandAsync catches WinRMException → returns Fail result
```

Do NOT modify production code. Only document what exception paths exist and need testing.
  </action>
  <verify>
Run `grep -c "catch (" src/WsusManager.Core/Services/*.cs` and verify:
1. All try-catch blocks in services are identified
2. Exception types are documented
3. Each catch block has a corresponding audit entry
  </verify>
  <done>
All exception handling paths in service layer are audited and documented with exception types and handler behavior
  </done>
</task>

<task type="auto">
  <name>Add SQL exception path tests for database operations</name>
  <files>
    src/WsusManager.Tests/Services/SqlServiceTests.cs
    src/WsusManager.Tests/Services/DatabaseOperationsServiceTests.cs
  </files>
  <action>
Add tests for SQL exception handling in SqlService and DatabaseOperationsService.

For each method that catches SqlException, add tests using Moq's `Throws`:

```csharp
[Fact]
public async Task ExecuteQueryAsync_Catches_SqlException_And_Returns_Fail()
{
    // Arrange
    _mockConnection.Setup(x => x.OpenAsync(It.IsAny<CancellationToken>()))
        .ThrowsAsync(new SqlException("Connection failed", null, 1));

    // Act
    var result = await _service.ExecuteQueryAsync("SELECT 1");

    // Assert
    Assert.False(result.IsSuccess);
    Assert.Contains("connection failed", result.ErrorMessage, StringComparison.OrdinalIgnoreCase);
}

[Fact]
public async Task BackupDatabaseAsync_Catches_SqlException_On_Backup_Command()
{
    // Arrange
    _mockProcessRunner.Setup(x => x.RunAsync(
        It.IsAny<string>(),
        It.IsAny<string>(),
        It.IsAny<IProgress<string>>(),
        It.IsAny<CancellationToken>()))
        .ThrowsAsync(new SqlException("Backup failed", null, 1));

    // Act
    var result = await _service.BackupDatabaseAsync(@"C:\WSUS\SUSDB", @"C:\backup.bak");

    // Assert
    Assert.False(result.IsSuccess);
    Assert.NotNull(result.ErrorMessage);
}
```

Follow existing test patterns. Add tests in a new "Exception Path Tests" region at the end of each test class.

For SQL-specific exceptions, note that SqlException requires special construction (use protected constructor or mock via Setup/Throws).

Target: 8-12 SQL exception tests across both services.
  </action>
  <verify>
Run `dotnet test src/WsusManager.Tests/WsusManager.Tests.csproj --filter "FullyQualifiedName~SqlServiceTests" --configuration Release` and verify:
1. All existing tests pass
2. New exception tests pass (catching SqlException and returning Fail result)
3. Tests verify both failure status and error messages

Repeat for DatabaseOperationsServiceTests.
  </verify>
  <done>
Database service exception handlers are tested and verified to catch SqlException and return appropriate OperationResult failures
  </done>
</task>

<task type="auto">
  <name>Add I/O and service exception path tests</name>
  <files>
    src/WsusManager.Tests/Services/WindowsServiceManagerTests.cs
    src/WsusManager.Tests/Services/WinRMServiceTests.cs
  </files>
  <action>
Add tests for IOException, service exceptions, and WinRM exceptions in WindowsServiceManager and WinRMService.

**WindowsServiceManager tests** (service not found, invalid operations):
```csharp
[Fact]
public async Task StartServiceAsync_Catches_ServiceNotFoundException()
{
    // Arrange
    _mockSCM.Setup(x => x.OpenService(It.IsAny<string>(), It.IsAny<ServiceAccessRights>()))
        .Throws(new InvalidOperationException("Service not found"));

    // Act
    var result = await _service.StartServiceAsync("NonExistentService");

    // Assert
    Assert.False(result.IsSuccess);
    Assert.Contains("not found", result.ErrorMessage, StringComparison.OrdinalIgnoreCase);
}

[Fact]
public async Task StopServiceAsync_Catches_InvalidOperationException_On_Already_Stopped()
{
    // Arrange
    _mockSCM.Setup(x => x.ControlService(It.IsAny<ServiceControl>()))
        .Throws(new InvalidOperationException("Service is not running"));

    // Act
    var result = await _service.StopServiceAsync("WsusService");

    // Assert
    Assert.False(result.IsSuccess);
}
```

**WinRMService tests** (connection failures, authentication errors):
```csharp
[Fact]
public async Task RunCommandAsync_Catches_WinRMException_And_Returns_Fail()
{
    // Arrange
    _mockWSMan.Setup(x => x.CreateSession())
        .Throws(new Exception("WinRM connection failed"));

    // Act
    var result = await _service.RunCommandAsync("server01", "Get-Service");

    // Assert
    Assert.False(result.IsSuccess);
    Assert.Contains("connection failed", result.ErrorMessage, StringComparison.OrdinalIgnoreCase);
}

[Fact]
public async Task RunCommandAsync_Catches_TimeoutException()
{
    // Arrange
    _mockWSMan.Setup(x => x.InvokeCommand())
        .Throws(new TimeoutException("Command timed out"));

    // Act
    var result = await _service.RunCommandAsync("server01", "Get-WsusServer");

    // Assert
    Assert.False(result.IsSuccess);
    Assert.Contains("timeout", result.ErrorMessage, StringComparison.OrdinalIgnoreCase);
}
```

Add tests in "Exception Path Tests" region. Target: 6-10 exception tests across both services.
  </action>
  <verify>
Run `dotnet test src/WsusManager.Tests/WsusManager.Tests.csproj --configuration Release` and verify:
1. All existing tests still pass
2. New exception tests pass
3. Tests verify both failure status and meaningful error messages

Check coverage report (if available) to confirm exception handler blocks are now covered.
  </verify>
  <done>
Service and WinRM exception handlers are tested and verified to properly transform exceptions into OperationResult failures
  </done>
</task>

</tasks>

<verification>
## Post-Execution Verification

### Exception Path Coverage
1. Run `dotnet test --settings src/coverlet.runsettings --collect:"XPlat Code Coverage"`
2. Generate coverage report with ReportGenerator
3. Open coverage report and check:
   - Try-catch blocks show branch coverage for both try and catch paths
   - Red highlighting reduced in exception handler code
   - Overall branch coverage increased from Plan 02 baseline

### Test Completeness
1. Compare exception audit list to tests added
2. Verify: Each audited exception path has at least one test
3. Verify: Tests use appropriate exception types (SqlException, IOException, etc.)
4. Verify: Tests verify both failure result and error message content

### Code Quality
1. Review exception tests for proper mock usage
2. Verify: No production code modified (only tests added)
3. Verify: Tests follow existing patterns in the codebase

### Regression Prevention
1. Run full test suite: `dotnet test --configuration Release`
2. Verify: All 336+ tests pass (existing + new)
3. Check for any flaky tests (random failures)
</verification>

<success_criteria>
## Phase 18 Success Criteria (Complete)

From this plan:
- [x] All exception handling paths have corresponding test coverage

Combined with Plans 01-02:
- [x] Developer can run `dotnet test` and generate HTML coverage report showing line/branch coverage
- [x] CI/CD pipeline produces coverage HTML artifact accessible from GitHub Actions run
- [x] Coverage report includes both line coverage percentage and branch coverage analysis
- [x] Edge cases (null inputs, empty collections, boundary values) are explicitly tested

**All 5 success criteria for Phase 18 are met.**
</success_criteria>

<output>
After completion, create `.planning/phases/18-test-coverage-reporting/18-03-SUMMARY.md` documenting:
1. Number of exception path tests added (by exception type)
2. Final coverage measurements (line % and branch % after all three plans)
3. Total tests added in Phase 18 (Plan 01 infrastructure + Plan 02 edge cases + Plan 03 exceptions)
4. List of any exception paths that could not be tested (with reason)
5. Recommendations for maintaining coverage as code evolves
</output>
