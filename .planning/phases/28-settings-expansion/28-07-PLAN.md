---
phase: 28-settings-expansion
plan: 07
type: execute
wave: 1
depends_on: ["28-01", "28-04", "28-05", "28-06"]
files_modified:
  - src/WsusManager.App/ViewModels/MainViewModel.cs
  - src/WsusManager.Core/Services/LoggingService.cs (or equivalent)
  - src/WsusManager.Tests/IntegrationTests.cs
autonomous: true
requirements:
  - UX-06

must_haves:
  truths:
    - "Log level setting controls which messages appear in log panel and log file"
    - "Dashboard refresh interval setting restarts timer with new value immediately"
    - "WinRM timeout and retry settings are used for client operations"
    - "All settings take effect without application restart"
    - "Integration tests verify settings integration with services"
  artifacts:
    - path: "src/WsusManager.App/ViewModels/MainViewModel.cs"
      provides: "Settings integration with application behavior"
      contains: "apply settings logic, timer restart, service configuration"
    - path: "src/WsusManager.Tests/SettingsIntegrationTests.cs"
      provides: "Integration tests for settings behavior"
      contains: "tests for log level, refresh interval, WinRM settings"
  key_links:
    - from: "MainViewModel"
      to: "AppSettings properties"
      via: "property access in operations"
      pattern: "settings application"
---

<objective>
Integrate all new settings into application behavior. Ensure log level, refresh interval, WinRM settings, and other options take effect immediately without restart. Add integration tests to verify behavior.

Purpose: Settings are only useful if they actually affect application behavior. This plan connects the settings properties to the actual application logic that uses them.

Output: Settings integrated throughout the application. All settings take effect immediately. Integration tests verify correct behavior.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/28-settings-expansion/28-CONTEXT.md
@src/WsusManager.App/ViewModels/MainViewModel.cs
@src/WsusManager.Core/Models/AppSettings.cs
</context>

<tasks>

<task type="auto">
  <name>Update dashboard refresh timer to use new setting</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Update the dashboard refresh timer logic to use the DashboardRefreshInterval setting:

    1. Find the timer initialization code (search for "Timer" or "RefreshTimer")

    2. Add a helper method to convert enum to milliseconds:

    ```csharp
    /// <summary>
    /// Converts DashboardRefreshInterval enum to milliseconds.
    /// Returns 0 for Disabled (timer should not be started).
    /// </summary>
    private int GetRefreshIntervalMs()
    {
        return _settings.DashboardRefreshInterval switch
        {
            DashboardRefreshInterval.Sec10 => 10000,
            DashboardRefreshInterval.Sec30 => 30000,
            DashboardRefreshInterval.Sec60 => 60000,
            DashboardRefreshInterval.Disabled => 0,
            _ => 30000 // default to 30 seconds
        };
    }
    ```

    3. Update timer initialization to use the setting:

    ```csharp
    private void InitializeRefreshTimer()
    {
        var intervalMs = GetRefreshIntervalMs();

        if (intervalMs == 0)
        {
            // Disabled - don't start timer
            _refreshTimer?.Stop();
            return;
        }

        _refreshTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromMilliseconds(intervalMs)
        };
        _refreshTimer.Tick += RefreshTimer_Tick;
        _refreshTimer.Start();
    }
    ```

    4. In OpenSettings method, after saving settings, restart timer if interval changed:

    ```csharp
    // Check if refresh interval changed (existing code)
    var intervalChanged = updated.DashboardRefreshInterval != _settings.DashboardRefreshInterval;

    // ... apply settings ...

    if (intervalChanged)
    {
        // Restart timer with new interval
        _refreshTimer?.Stop();
        InitializeRefreshTimer();
    }
    ```

    DO NOT: Create multiple timer instances - stop and dispose old timer before creating new one
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    Dashboard refresh timer uses DashboardRefreshInterval setting, restarts when setting changes, supports Disabled option
  </done>
</task>

<task type="auto">
  <name>Apply WinRM timeout and retry settings to client operations</name>
  <files>src/WsusManager.Core/Services/WsusClientService.cs (or equivalent)</files>
  <action>
    Find the service that handles WinRM operations and update to use settings:

    1. Locate the WinRM client service (search for "WinRM", "timeout", "retry")

    2. Inject ISettingsProvider or AppSettings into the service

    3. Update timeout and retry constants to use settings:

    ```csharp
    // Before (hardcoded)
    private const int WinRMTimeoutMs = 60000;
    private const int WinRMMRetryCount = 3;

    // After (from settings)
    private int WinRMTimeoutMs => _settings.WinRMTimeoutSeconds * 1000;
    private int WinRMRetryCount => _settings.WinRMRetryCount;
    ```

    4. Ensure settings are accessed fresh each time (not cached) so changes take effect immediately

    Note: If WinRM settings are not yet used in the codebase, create a TODO comment for future implementation:

    ```csharp
    // TODO: Phase 28 - Apply WinRMTimeoutSeconds and WinRMRetryCount settings
    // Currently using default values
    ```

    DO NOT: Break existing WinRM operations - ensure defaults match previous hardcoded values
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    WinRM timeout and retry settings applied to client operations (or TODO added for future implementation)
  </done>
</task>

<task type="auto">
  <name>Apply log level setting to logging service</name>
  <files>src/WsusManager.Core/Services/LoggingService.cs (or equivalent)</files>
  <action>
    Update the logging service to respect the LogLevel setting:

    1. Find the logging service (search for "Log", "AppendLog", "WriteLog")

    2. Add or update log level filtering:

    ```csharp
    public enum LogLevel
    {
        Debug = 0,
        Info = 1,
        Warning = 2,
        Error = 3,
        Fatal = 4
    }

    public void Log(string message, Models.LogLevel level = Models.LogLevel.Info)
    {
        // Filter based on settings
        if (level < _settings.LogLevel)
            return;

        // ... existing logging code ...
    }
    ```

    3. Ensure MainViewModel passes the log level when calling Log methods:

    ```csharp
    _loggingService.Log("Info message", Models.LogLevel.Info);
    _loggingService.Log("Warning message", Models.LogLevel.Warning);
    ```

    Note: If the current logging implementation doesn't support levels, add a TODO:

    ```csharp
    // TODO: Phase 28 - Apply LogLevel setting to filter log output
    // Currently logging all messages
    ```

    DO NOT: Change existing log calls throughout the codebase in this phase - just add the filtering infrastructure
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    Logging service filters messages based on LogLevel setting (or TODO added for future implementation)
  </done>
</task>

<task type="auto">
  <name>Create integration tests for settings behavior</name>
  <files>src/WsusManager.Tests/SettingsIntegrationTests.cs</files>
  <action>
    Create integration tests to verify settings affect application behavior:

    ```csharp
    using Xunit;
    using WsusManager.Core.Models;
    using WsusManager.App.ViewModels;

    namespace WsusManager.Tests;

    public class SettingsIntegrationTests : IClassFixture<TestFixture>
    {
        private readonly TestFixture _fixture;

        public SettingsIntegrationTests(TestFixture fixture)
        {
            _fixture = fixture;
        }

        [Fact]
        public void DashboardRefreshInterval_Disabled_StopsTimer()
        {
            // Arrange
            var settings = new AppSettings
            {
                DashboardRefreshInterval = DashboardRefreshInterval.Sec30
            };
            var viewModel = _fixture.CreateViewModel(settings);

            // Act
            settings.DashboardRefreshInterval = DashboardRefreshInterval.Disabled;
            // Trigger settings application (would need a public method or event)

            // Assert
            // Verify timer is stopped
        }

        [Fact]
        public void RequireConfirmationDestructive_False_SkipsConfirmation()
        {
            // Test that destructive operations skip confirmation when setting is false
        }

        [Fact]
        public void PersistWindowState_False_DoesNotSaveBounds()
        {
            // Test that window bounds are not saved when setting is false
        }

        // Add more tests as needed...
    }
    ```

    Note: Many of these tests may require UI testing framework (like Appium) or may need to be manual tests.

    For now, focus on unit tests that can verify settings model behavior:

    DO NOT: Create UI-dependent tests without proper testing framework - stick to unit tests for settings model
  </action>
  <verify>
    dotnet test src/WsusManager.Tests/WsusManager.Tests.csproj --filter "FullyQualifiedName~SettingsIntegrationTests"
  </verify>
  <done>
    SettingsIntegrationTests.cs created with tests for settings model behavior and basic integration scenarios
  </done>
</task>

<task type="auto">
  <name>Update MainViewModel to apply DefaultSyncProfile setting</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Update the Online Sync dialog to use the DefaultSyncProfile setting:

    1. Find the method that opens the Online Sync dialog (search for "MonthlyMaintenance" or "OnlineSync")

    2. When creating or showing the sync profile dialog, pre-select the default profile:

    ```csharp
    private async Task RunOnlineSyncAsync()
    {
        // Pre-select the default profile from settings
        var defaultProfile = _settings.DefaultSyncProfile;

        // Show dialog with default profile pre-selected
        var dialog = new OnlineSyncDialog(defaultProfile);
        // ... rest of code
    }
    ```

    Note: The exact implementation depends on how the Online Sync dialog is structured. The key is to pass the default profile to the dialog constructor or pre-select it before showing.

    DO NOT: Force the profile - user should still be able to change it before running the operation
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    Online Sync dialog uses DefaultSyncProfile setting to pre-select profile, user can still change before running
  </done>
</task>

<task type="auto">
  <name>Add manual test verification checklist</name>
  <files>.planning/phases/28-settings-expansion/28-MANUAL-TESTS.md</files>
  <action>
    Create a manual test checklist for verifying settings behavior:

    ```markdown
    # Phase 28 Manual Test Checklist

    ## Settings Dialog
    - [ ] Settings dialog opens from toolbar
    - [ ] All 4 sections display correctly
    - [ ] All controls pre-populated from current settings
    - [ ] Save button validates all settings
    - [ ] Cancel button closes without saving
    - [ ] Reset to Defaults shows confirmation and resets all values
    - [ ] Theme preview works and reverts on cancel

    ## Settings Behavior
    - [ ] Log Level: Debug shows all messages, Fatal shows only critical
    - [ ] Refresh Interval: Changes take effect immediately (timer restart)
    - [ ] Refresh Interval: Disabled stops auto-refresh
    - [ ] Default Sync Profile: Online Sync dialog pre-selects correct profile
    - [ ] Confirmation Prompts: Destructive ops show/hide based on setting
    - [ ] Window State Persistence: Position/size saved and restored
    - [ ] WinRM Settings: Applied to client operations (if implemented)

    ## Validation
    - [ ] Retention Days: Rejects < 1 or > 365
    - [ ] Max File Size: Rejects < 1 or > 1000
    - [ ] WinRM Timeout: Rejects < 10 or > 300
    - [ ] WinRM Retry Count: Rejects < 1 or > 10
    - [ ] Red border shown on invalid controls
    - [ ] Error message in tooltip on invalid controls

    ## Edge Cases
    - [ ] Settings file missing: Uses defaults
    - [ ] Corrupt settings file: Uses defaults
    - [ ] Invalid window bounds: Falls back to default size
    - [ ] Multi-monitor with saved bounds on disconnected monitor: Falls back to primary
    ```

    DO NOT: Automate these tests - they require manual verification
  </action>
  <verify>
    File .planning/phases/28-settings-expansion/28-MANUAL-TESTS.md exists
  </verify>
  <done>
    Manual test checklist created with all verification scenarios
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: dotnet build src/WsusManager.App
2. Dashboard refresh interval setting controls timer behavior
3. Default sync profile pre-selected in Online Sync dialog
4. Confirmation prompts controlled by RequireConfirmationDestructive setting
5. Window state persistence saves/restores correctly
6. Log level filters log output (or TODO added)
7. WinRM settings applied to operations (or TODO added)
8. Integration tests created for settings behavior
9. Manual test checklist created
</verification>

<success_criteria>
All settings integrated into application behavior. Settings take effect immediately without restart. Integration tests verify correct behavior. Manual test checklist documents verification steps.
</success_criteria>

<output>
After completion, create `.planning/phases/28-settings-expansion/28-07-SUMMARY.md`
</output>
