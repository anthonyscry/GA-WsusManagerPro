---
phase: 28-settings-expansion
plan: 05
type: execute
wave: 1
depends_on: ["28-01"]
files_modified:
  - src/WsusManager.Core/Models/WindowBounds.cs
  - src/WsusManager.Core/Models/AppSettings.cs
  - src/WsusManager.App/Views/MainWindow.xaml.cs
autonomous: true
requirements:
  - UX-06

must_haves:
  truths:
    - "WindowBounds model stores Width, Height, Left, Top, WindowState"
    - "AppSettings has WindowBounds property for persistence"
    - "MainWindow saves bounds on closing event"
    - "MainWindow restores bounds on startup if within screen working area"
    - "Fallback to default size if saved bounds invalid or span multiple monitors"
  artifacts:
    - path: "src/WsusManager.Core/Models/WindowBounds.cs"
      provides: "Window position and state storage model"
      contains: "class WindowBounds"
    - path: "src/WsusManager.App/Views/MainWindow.xaml.cs"
      provides: "Window bounds save/restore logic"
      contains: "Closing event handler, Loaded event handler"
  key_links:
    - from: "MainWindow"
      to: "AppSettings.WindowBounds"
      via: "settings save/load"
      pattern: "property access"
---

<objective>
Implement window state persistence to save and restore window position, size, and state between application sessions. Handle multi-monitor scenarios and invalid bounds gracefully.

Purpose: Users expect applications to remember their window position and size. This improves user experience by maintaining the workspace layout across sessions.

Output: WindowBounds model, AppSettings.WindowBounds property, MainWindow save/restore logic with fallback handling.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/28-settings-expansion/28-CONTEXT.md
@src/WsusManager.Core/Models/AppSettings.cs
@src/WsusManager.App/Views/MainWindow.xaml
</context>

<tasks>

<task type="auto">
  <name>Create WindowBounds model</name>
  <files>src/WsusManager.Core/Models/WindowBounds.cs</files>
  <action>
    Create a new model file src/WsusManager.Core/Models/WindowBounds.cs:

    ```csharp
    using System.Text.Json.Serialization;

    namespace WsusManager.Core.Models;

    /// <summary>
    /// Window position and state for persistence. Stores the window's
    /// bounds and maximized state to restore on next launch.
    /// </summary>
    public class WindowBounds
    {
        /// <summary>Window width in pixels.</summary>
        [JsonPropertyName("width")]
        public double Width { get; set; } = 1280;

        /// <summary>Window height in pixels.</summary>
        [JsonPropertyName("height")]
        public double Height { get; set; } = 720;

        /// <summary>Window left position in pixels.</summary>
        [JsonPropertyName("left")]
        public double Left { get; set; } = 100;

        /// <summary>Window top position in pixels.</summary>
        [JsonPropertyName("top")]
        public double Top { get; set; } = 100;

        /// <summary>Window state (Normal, Maximized).</summary>
        [JsonPropertyName("windowState")]
        public string WindowState { get; set; } = "Normal";

        /// <summary>
        /// Checks if the bounds are valid for the current screen configuration.
        /// Bounds are invalid if they span multiple monitors or are outside the working area.
        /// </summary>
        public bool IsValid()
        {
            // Check for NaN or infinity
            if (double.IsNaN(Width) || double.IsInfinity(Width) ||
                double.IsNaN(Height) || double.IsInfinity(Height) ||
                double.IsNaN(Left) || double.IsInfinity(Left) ||
                double.IsNaN(Top) || double.IsInfinity(Top))
            {
                return false;
            }

            // Check for reasonable minimum size
            if (Width < 400 || Height < 300)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Checks if the bounds are within the primary screen's working area.
        /// </summary>
        public bool IsWithinScreenBounds()
        {
            try
            {
                var workingArea = SystemParameters.WorkArea;
                return Left >= workingArea.Left &&
                       Top >= workingArea.Top &&
                       Left + Width <= workingArea.Right &&
                       Top + Height <= workingArea.Bottom;
            }
            catch
            {
                return false;
            }
        }
    }
    ```

    DO NOT: Store Minimized state - always restore as Normal or Maximized
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    WindowBounds.cs exists with 5 properties, IsValid method, IsWithinScreenBounds method, all with JSON serialization
  </done>
</task>

<task type="auto">
  <name>Add WindowBounds property to AppSettings</name>
  <files>src/WsusManager.Core/Models/AppSettings.cs</files>
  <action>
    Add the WindowBounds property to AppSettings.cs:

    1. Add using statement if not present:
    ```csharp
    using System.Windows;
    ```

    2. Add the property in the Behavior section:

    ```csharp
    // Behavior
    /// <summary>Whether to save and restore window position and size.</summary>
    [JsonPropertyName("persistWindowState")]
    public bool PersistWindowState { get; set; } = true;

    /// <summary>Window bounds for persistence (if PersistWindowState is true).</summary>
    [JsonPropertyName("windowBounds")]
    public WindowBounds? WindowBounds { get; set; }
    ```

    DO NOT: Initialize WindowBounds with a default instance - null allows fallback to default window size
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    AppSettings has WindowBounds property with JsonPropertyName attribute, null by default
  </done>
</task>

<task type="auto">
  <name>Add window bounds save logic to MainWindow closing event</name>
  <files>src/WsusManager.App/Views/MainWindow.xaml.cs</files>
  <action>
    Update MainWindow.xaml.cs to save window bounds on closing:

    1. Find or add the Closing event handler

    2. Add logic to save window bounds if PersistWindowState is enabled:

    ```csharp
    private void MainWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
    {
        // Existing cleanup code...

        // Save window bounds if enabled
        if (_settings.PersistWindowState)
        {
            _settings.WindowBounds = new Core.Models.WindowBounds
            {
                Width = WindowState == WindowState.Maximized ? RestoreBounds.Width : ActualWidth,
                Height = WindowState == WindowState.Maximized ? RestoreBounds.Height : ActualHeight,
                Left = WindowState == WindowState.Maximized ? RestoreBounds.Left : Left,
                Top = WindowState == WindowState.Maximized ? RestoreBounds.Top : Top,
                WindowState = WindowState == WindowState.Maximized ? "Maximized" : "Normal"
            };

            // Save settings (this should trigger existing save logic)
            // Note: The actual save happens elsewhere - this just updates the property
        }
    }
    ```

    DO NOT: Save RestoreBounds when window is Normal - only use RestoreBounds when Maximized to get the pre-maximized size
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    MainWindow_Closing handler saves WindowBounds to settings when PersistWindowState is true
  </done>
</task>

<task type="auto">
  <name>Add window bounds restore logic to MainWindow loaded event</name>
  <files>src/WsusManager.App/Views/MainWindow.xaml.cs</files>
  <action>
    Update MainWindow.xaml.cs to restore window bounds on startup:

    1. Find or add the Loaded event handler (or add in constructor after InitializeComponent)

    2. Add logic to restore window bounds if PersistWindowState is enabled and bounds are valid:

    ```csharp
    private void MainWindow_Loaded(object sender, RoutedEventArgs e)
    {
        // Restore window bounds if enabled
        if (_settings.PersistWindowState && _settings.WindowBounds != null)
        {
            var bounds = _settings.WindowBounds;

            // Validate bounds are within screen
            if (bounds.IsValid() && bounds.IsWithinScreenBounds())
            {
                Width = bounds.Width;
                Height = bounds.Height;
                Left = bounds.Left;
                Top = bounds.Top;

                if (string.Equals(bounds.WindowState, "Maximized", StringComparison.Ordinal))
                {
                    WindowState = WindowState.Maximized;
                }
            }
            // If bounds invalid, use default XAML values
        }

        // Unsubscribe from Loaded event to prevent memory leak
        Loaded -= MainWindow_Loaded;
    }
    ```

    3. Wire up the Loaded event in constructor or XAML:
    ```csharp
    // In constructor after InitializeComponent()
    Loaded += MainWindow_Loaded;
    ```

    DO NOT: Apply bounds if they span multiple monitors - IsWithinScreenBounds checks for this
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    MainWindow_Loaded handler restores WindowBounds when PersistWindowState is true and bounds are valid, unsubscribes after execution
  </done>
</task>

<task type="auto">
  <name>Handle PersistWindowState false case</name>
  <files>src/WsusManager.App/Views/MainWindow.xaml.cs</files>
  <action>
    Ensure window bounds are not saved when PersistWindowState is false:

    1. Update MainWindow_Closing to check the setting:
    ```csharp
    if (_settings.PersistWindowState && _settings.WindowBounds != null)
    {
        // Save bounds as above
    }
    else if (!_settings.PersistWindowState)
    {
        // Clear saved bounds
        _settings.WindowBounds = null;
    }
    ```

    2. This ensures that if user disables the setting, any previously saved bounds are cleared

    DO NOT: Save bounds when setting is disabled - user explicitly chose not to persist
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    PersistWindowState false clears WindowBounds property, bounds not saved on closing
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: dotnet build src/WsusManager.App
2. WindowBounds model exists with all required properties and validation methods
3. AppSettings.WindowBounds property exists and is nullable
4. MainWindow saves bounds on closing (if PersistWindowState is true)
5. MainWindow restores bounds on loaded (if PersistWindowState is true and bounds valid)
6. Fallback to default size when bounds invalid or null
7. Loaded event unsubscribes after execution to prevent memory leak
</verification>

<success_criteria>
Window state persistence implemented. Window position and size saved on close, restored on open. Handles invalid bounds gracefully with fallback to defaults.
</success_criteria>

<output>
After completion, create `.planning/phases/28-settings-expansion/28-05-SUMMARY.md`
</output>
