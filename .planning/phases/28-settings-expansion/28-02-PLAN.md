---
phase: 28-settings-expansion
plan: 02
type: execute
wave: 1
depends_on: ["28-01"]
files_modified:
  - src/WsusManager.Core/Services/Interfaces/ISettingsValidationService.cs
  - src/WsusManager.Core/Services/SettingsValidationService.cs
  - src/WsusManager.App/Program.cs
autonomous: true
requirements:
  - UX-06

must_haves:
  truths:
    - "ISettingsValidationService interface defines validation methods"
    - "SettingsValidationService validates all numeric settings with min/max ranges"
    - "ValidationResult model provides error messages and IsValid flag"
    - "Service registered in DI container for injection into SettingsDialog"
  artifacts:
    - path: "src/WsusManager.Core/Services/Interfaces/ISettingsValidationService.cs"
      provides: "Interface for settings validation"
      contains: "interface ISettingsValidationService"
    - path: "src/WsusManager.Core/Services/SettingsValidationService.cs"
      provides: "Validation implementation for numeric ranges"
      contains: "class SettingsValidationService"
    - path: "src/WsusManager.Core/Models/ValidationResult.cs"
      provides: "Validation result model"
      contains: "class ValidationResult"
  key_links:
    - from: "SettingsDialog"
      to: "ISettingsValidationService"
      via: "constructor injection"
      pattern: "dependency injection"
---

<objective>
Create a validation service for settings input. Validate numeric ranges for retention days, max file size, WinRM timeout, and retry count. Provide clear error messages for invalid input.

Purpose: Settings dialog needs validation to prevent users from entering invalid values (e.g., negative retention days, extremely large file sizes). Centralized validation ensures consistency across the application.

Output: ISettingsValidationService interface, SettingsValidationService implementation, ValidationResult model, all registered in DI.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/28-settings-expansion/28-CONTEXT.md
@src/WsusManager.Core/Models/AppSettings.cs
</context>

<tasks>

<task type="auto">
  <name>Create ValidationResult model</name>
  <files>src/WsusManager.Core/Models/ValidationResult.cs</files>
  <action>
    Create a new model file src/WsusManager.Core/Models/ValidationResult.cs:

    ```csharp
    namespace WsusManager.Core.Models;

    /// <summary>
    /// Result of a settings validation operation. Indicates success or failure
    /// with an optional error message.
    /// </summary>
    public class ValidationResult
    {
        /// <summary>Gets whether the validation passed.</summary>
        public bool IsValid { get; init; }

        /// <summary>Gets the error message if validation failed.</summary>
        public string? ErrorMessage { get; init; }

        /// <summary>Creates a successful validation result.</summary>
        public static ValidationResult Success => new() { IsValid = true };

        /// <summary>Creates a failed validation result with an error message.</summary>
        public static ValidationResult Fail(string message) => new()
        {
            IsValid = false,
            ErrorMessage = message
        };
    }
    ```

    DO NOT: Add validation rules to this class - it's just a data carrier
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    ValidationResult.cs exists with IsValid, ErrorMessage, Success factory, Fail factory
  </done>
</task>

<task type="auto">
  <name>Create ISettingsValidationService interface</name>
  <files>src/WsusManager.Core/Services/Interfaces/ISettingsValidationService.cs</files>
  <action>
    Create a new interface file src/WsusManager.Core/Services/Interfaces/ISettingsValidationService.cs:

    ```csharp
    using WsusManager.Core.Models;

    namespace WsusManager.Core.Services.Interfaces;

    /// <summary>
    /// Provides validation for application settings values.
    /// </summary>
    public interface ISettingsValidationService
    {
        /// <summary>Validates log retention days (1-365).</summary>
        ValidationResult ValidateRetentionDays(int days);

        /// <summary>Validates max log file size in MB (1-1000).</summary>
        ValidationResult ValidateMaxFileSizeMb(int sizeMb);

        /// <summary>Validates WinRM timeout in seconds (10-300).</summary>
        ValidationResult ValidateWinRMTimeoutSeconds(int timeout);

        /// <summary>Validates WinRM retry count (1-10).</summary>
        ValidationResult ValidateWinRMRetryCount(int count);

        /// <summary>Validates all settings in an AppSettings instance.</summary>
        ValidationResult ValidateAll(AppSettings settings);
    }
    ```

    DO NOT: Add async methods - validation is synchronous and fast
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    ISettingsValidationService.cs exists with 5 validation method signatures
  </done>
</task>

<task type="auto">
  <name>Implement SettingsValidationService</name>
  <files>src/WsusManager.Core/Services/SettingsValidationService.cs</files>
  <action>
    Create the implementation file src/WsusManager.Core/Services/SettingsValidationService.cs:

    ```csharp
    using WsusManager.Core.Models;
    using WsusManager.Core.Services.Interfaces;

    namespace WsusManager.Core.Services;

    /// <summary>
    /// Validates settings values against acceptable ranges.
    /// </summary>
    public class SettingsValidationService : ISettingsValidationService
    {
        private const int MinRetentionDays = 1;
        private const int MaxRetentionDays = 365;
        private const int MinMaxFileSizeMb = 1;
        private const int MaxMaxFileSizeMb = 1000;
        private const int MinWinRMTimeoutSeconds = 10;
        private const int MaxWinRMTimeoutSeconds = 300;
        private const int MinWinRMRetryCount = 1;
        private const int MaxWinRMRetryCount = 10;

        public ValidationResult ValidateRetentionDays(int days)
        {
            if (days < MinRetentionDays || days > MaxRetentionDays)
            {
                return ValidationResult.Fail(
                    $"Log retention must be between {MinRetentionDays} and {MaxRetentionDays} days.");
            }
            return ValidationResult.Success;
        }

        public ValidationResult ValidateMaxFileSizeMb(int sizeMb)
        {
            if (sizeMb < MinMaxFileSizeMb || sizeMb > MaxMaxFileSizeMb)
            {
                return ValidationResult.Fail(
                    $"Max file size must be between {MinMaxFileSizeMb} and {MaxMaxFileSizeMb} MB.");
            }
            return ValidationResult.Success;
        }

        public ValidationResult ValidateWinRMTimeoutSeconds(int timeout)
        {
            if (timeout < MinWinRMTimeoutSeconds || timeout > MaxWinRMTimeoutSeconds)
            {
                return ValidationResult.Fail(
                    $"WinRM timeout must be between {MinWinRMTimeoutSeconds} and {MaxWinRMTimeoutSeconds} seconds.");
            }
            return ValidationResult.Success;
        }

        public ValidationResult ValidateWinRMRetryCount(int count)
        {
            if (count < MinWinRMRetryCount || count > MaxWinRMRetryCount)
            {
                return ValidationResult.Fail(
                    $"WinRM retry count must be between {MinWinRMRetryCount} and {MaxWinRMRetryCount}.");
            }
            return ValidationResult.Success;
        }

        public ValidationResult ValidateAll(AppSettings settings)
        {
            var retentionResult = ValidateRetentionDays(settings.LogRetentionDays);
            if (!retentionResult.IsValid) return retentionResult;

            var sizeResult = ValidateMaxFileSizeMb(settings.LogMaxFileSizeMb);
            if (!sizeResult.IsValid) return sizeResult;

            var timeoutResult = ValidateWinRMTimeoutSeconds(settings.WinRMTimeoutSeconds);
            if (!timeoutResult.IsValid) return timeoutResult;

            var retryResult = ValidateWinRMRetryCount(settings.WinRMRetryCount);
            if (!retryResult.IsValid) return retryResult;

            return ValidationResult.Success;
        }
    }
    ```

    DO NOT: Use magic numbers - define constants for min/max values at class level
  </action>
  <verify>
    dotnet build src/WsusManager.Core/WsusManager.Core.csproj succeeds
  </verify>
  <done>
    SettingsValidationService.cs exists with all validation methods implemented using constants
  </done>
</task>

<task type="auto">
  <name>Register SettingsValidationService in DI container</name>
  <files>src/WsusManager.App/Program.cs</files>
  <action>
    Update src/WsusManager.App/Program.cs to register the validation service:

    1. Find the ConfigureServices method or equivalent DI registration section
    2. Add the service registration:

    ```csharp
    services.AddSingleton<ISettingsValidationService, SettingsValidationService>();
    ```

    3. Ensure the using statement exists:
    ```csharp
    using WsusManager.Core.Services.Interfaces;
    ```

    DO NOT: Register as scoped - use singleton since validation is stateless
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    ISettingsValidationService registered as singleton in DI container
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: dotnet build src/WsusManager.App
2. ValidationResult model provides IsValid and ErrorMessage
3. All 4 individual validation methods work with correct ranges
4. ValidateAll method returns first validation failure
5. Service is registered in DI and can be injected
</verification>

<success_criteria>
SettingsValidationService created and registered in DI. All numeric settings validated against min/max ranges. Clear error messages provided for invalid input.
</success_criteria>

<output>
After completion, create `.planning/phases/28-settings-expansion/28-02-SUMMARY.md`
</output>
