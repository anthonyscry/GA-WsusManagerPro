---
phase: 28-settings-expansion
plan: 04
type: execute
wave: 1
depends_on: ["28-01", "28-02", "28-03"]
files_modified:
  - src/WsusManager.App/Views/SettingsDialog.xaml.cs
autonomous: true
requirements:
  - UX-06

must_haves:
  truths:
    - "SettingsDialog injects ISettingsValidationService via constructor"
    - "All new controls pre-populated from current AppSettings"
    - "Validation runs on TextBox.LostFocus with red border for invalid controls"
    - "Reset to Defaults shows confirmation dialog and resets all settings"
    - "Save button validates all settings before closing"
    - "Cancel button reverts theme and closes without saving"
  artifacts:
    - path: "src/WsusManager.App/Views/SettingsDialog.cs"
      provides: "Code-behind for settings dialog with validation"
      contains: "validation logic, reset handler, save/load logic"
  key_links:
    - from: "SettingsDialog.xaml.cs"
      to: "ISettingsValidationService"
      via: "constructor injection"
      pattern: "dependency injection"
    - from: "SettingsDialog.xaml.cs"
      to: "AppSettings"
      via: "property mapping"
      pattern: "data binding"
---

<objective>
Update SettingsDialog code-behind to handle all new controls. Implement validation on numeric inputs. Handle Reset to Defaults with confirmation. Ensure proper state management for OK/Cancel/Reset.

Purpose: XAML controls need code-behind logic to load/save settings, validate input, and handle the Reset to Defaults action. Validation prevents invalid values from being saved.

Output: SettingsDialog.xaml.cs with validation, reset handling, proper state management for all 8 new settings.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/28-settings-expansion/28-CONTEXT.md
@src/WsusManager.App/Views/SettingsDialog.xaml.cs
@src/WsusManager.Core/Services/Interfaces/ISettingsValidationService.cs
</context>

<tasks>

<task type="auto">
  <name>Inject ISettingsValidationService and add private fields</name>
  <files>src/WsusManager.App/Views/SettingsDialog.xaml.cs</files>
  <action>
    Update SettingsDialog.xaml.cs to inject the validation service:

    1. Add using statement:
    ```csharp
    using WsusManager.Core.Services.Interfaces;
    ```

    2. Add private readonly field after _themeService:
    ```csharp
    private readonly ISettingsValidationService _validationService;
    ```

    3. Update constructor signature to inject service:
    ```csharp
    public SettingsDialog(AppSettings current, IThemeService themeService, ISettingsValidationService validationService)
    ```

    4. Initialize field in constructor:
    ```csharp
    _validationService = validationService;
    ```

    DO NOT: Break existing constructor calls - MainViewModel will need to pass the service
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    ISettingsValidationService injected via constructor, stored in private field
  </done>
</task>

<task type="auto">
  <name>Pre-populate new controls from current settings</name>
  <files>src/WsusManager.App/Views/SettingsDialog.xaml.cs</files>
  <action>
    Add code in constructor (after existing population code) to pre-populate new controls:

    ```csharp
    // Populate Operations section
    PopulateComboBoxFromEnum(CboDefaultSyncProfile, current.DefaultSyncProfile.ToString());

    // Populate Logging section
    PopulateComboBoxFromEnum(CboLogLevel, current.LogLevel.ToString());
    TxtLogRetentionDays.Text = current.LogRetentionDays.ToString();
    TxtLogMaxFileSizeMb.Text = current.LogMaxFileSizeMb.ToString();

    // Populate Behavior section
    ChkPersistWindowState.IsChecked = current.PersistWindowState;
    PopulateComboBoxFromEnum(CboDashboardRefreshInterval, current.DashboardRefreshInterval.ToString());
    ChkRequireConfirmationDestructive.IsChecked = current.RequireConfirmationDestructive;

    // Populate Advanced section
    TxtWinRMTimeoutSeconds.Text = current.WinRMTimeoutSeconds.ToString();
    TxtWinRMRetryCount.Text = current.WinRMRetryCount.ToString();
    ```

    Add helper method (or inline similar logic):
    ```csharp
    private void PopulateComboBoxFromEnum(ComboBox comboBox, string enumValue)
    {
        foreach (var item in comboBox.Items)
        {
            if (item is ComboBoxItem cbi && string.Equals(cbi.Tag?.ToString(), enumValue, StringComparison.Ordinal))
            {
                comboBox.SelectedItem = cbi;
                break;
            }
        }
    }
    ```

    DO NOT: Assume ComboBoxItem Content matches enum value - use Tag property for comparison
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    All new controls pre-populated from current AppSettings values using Tag-based enum matching
  </done>
</task>

<task type="auto">
  <name>Add LostFocus validation handlers for numeric TextBoxes</name>
  <files>src/WsusManager.App/Views/SettingsDialog.xaml.cs</files>
  <action>
    Add validation event handlers in constructor for numeric TextBoxes:

    ```csharp
    // Wire up validation handlers
    TxtLogRetentionDays.LostFocus += (s, e) => ValidateNumericTextBox(
        TxtLogRetentionDays,
        int.TryParse(TxtLogRetentionDays.Text, out var days) ? days : 0,
        _validationService.ValidateRetentionDays(days));

    TxtLogMaxFileSizeMb.LostFocus += (s, e) => ValidateNumericTextBox(
        TxtLogMaxFileSizeMb,
        int.TryParse(TxtLogMaxFileSizeMb.Text, out var size) ? size : 0,
        _validationService.ValidateMaxFileSizeMb(size));

    TxtWinRMTimeoutSeconds.LostFocus += (s, e) => ValidateNumericTextBox(
        TxtWinRMTimeoutSeconds,
        int.TryParse(TxtWinRMTimeoutSeconds.Text, out var timeout) ? timeout : 0,
        _validationService.ValidateWinRMTimeoutSeconds(timeout));

    TxtWinRMRetryCount.LostFocus += (s, e) => ValidateNumericTextBox(
        TxtWinRMRetryCount,
        int.TryParse(TxtWinRMRetryCount.Text, out var count) ? count : 0,
        _validationService.ValidateWinRMRetryCount(count));
    ```

    Add helper method for validation feedback:
    ```csharp
    private void ValidateNumericTextBox(TextBox textBox, int value, ValidationResult result)
    {
        if (result.IsValid)
        {
            textBox.BorderBrush = (Brush)FindResource("BorderPrimary");
            textBox.ToolTip = null;
        }
        else
        {
            textBox.BorderBrush = new SolidColorBrush(Colors.Red);
            textBox.ToolTip = result.ErrorMessage;
        }
    }
    ```

    DO NOT: Show MessageBox on LostFocus - use visual feedback (red border + tooltip)
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    LostFocus handlers added for all 4 numeric TextBoxes with visual validation feedback
  </done>
</task>

<task type="auto">
  <name>Implement Reset to Defaults button handler</name>
  <files>src/WsusManager.App/Views/SettingsDialog.xaml.cs</files>
  <action>
    Add Reset to Defaults button click handler:

    ```csharp
    private void BtnResetToDefaults_Click(object sender, RoutedEventArgs e)
    {
        // Show confirmation dialog
        var result = MessageBox.Show(
            "Reset all settings to default values? This cannot be undone.",
            "Reset to Defaults",
            MessageBoxButton.YesNo,
            MessageBoxImage.Warning);

        if (result != MessageBoxResult.Yes)
            return;

        // Create default AppSettings
        var defaults = new AppSettings();

        // Reset all controls to default values
        // Server Mode
        foreach (var item in CboServerMode.Items)
        {
            if (item is ComboBoxItem cbi && string.Equals(cbi.Content?.ToString(), "Online", StringComparison.Ordinal))
                CboServerMode.SelectedItem = cbi;
        }

        // Refresh Interval (existing)
        TxtRefreshInterval.Text = defaults.RefreshIntervalSeconds.ToString();
        TxtContentPath.Text = defaults.ContentPath;
        TxtSqlInstance.Text = defaults.SqlInstance;

        // New controls
        PopulateComboBoxFromEnum(CboDefaultSyncProfile, defaults.DefaultSyncProfile.ToString());
        PopulateComboBoxFromEnum(CboLogLevel, defaults.LogLevel.ToString());
        TxtLogRetentionDays.Text = defaults.LogRetentionDays.ToString();
        TxtLogMaxFileSizeMb.Text = defaults.LogMaxFileSizeMb.ToString();
        ChkPersistWindowState.IsChecked = defaults.PersistWindowState;
        PopulateComboBoxFromEnum(CboDashboardRefreshInterval, defaults.DashboardRefreshInterval.ToString());
        ChkRequireConfirmationDestructive.IsChecked = defaults.RequireConfirmationDestructive;
        TxtWinRMTimeoutSeconds.Text = defaults.WinRMTimeoutSeconds.ToString();
        TxtWinRMRetryCount.Text = defaults.WinRMRetryCount.ToString();

        // Reset theme
        _previewTheme = defaults.SelectedTheme;
        _themeService.ApplyTheme(_previewTheme);
        BuildThemeSwatches();

        // Clear any validation errors
        ClearValidationErrors();
    }

    private void ClearValidationErrors()
    {
        var primaryBorder = (Brush)FindResource("BorderPrimary");
        TxtLogRetentionDays.BorderBrush = primaryBorder;
        TxtLogRetentionDays.ToolTip = null;
        TxtLogMaxFileSizeMb.BorderBrush = primaryBorder;
        TxtLogMaxFileSizeMb.ToolTip = null;
        TxtWinRMTimeoutSeconds.BorderBrush = primaryBorder;
        TxtWinRMTimeoutSeconds.ToolTip = null;
        TxtWinRMRetryCount.BorderBrush = primaryBorder;
        TxtWinRMRetryCount.ToolTip = null;
    }
    ```

    DO NOT: Auto-save on reset - user must still click Save to persist changes
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    BtnResetToDefaults_Click handler added with confirmation dialog, resets all controls to default values, clears validation errors
  </done>
</task>

<task type="auto">
  <name>Update BtnSave_Click to handle new properties and validation</name>
  <files>src/WsusManager.App/Views/SettingsDialog.xaml.cs</files>
  <action>
    Update the BtnSave_Click method to include new properties and validation:

    1. Add validation check at the start (after existing validation):

    ```csharp
    // Validate new numeric fields
    var retentionResult = _validationService.ValidateRetentionDays(
        int.TryParse(TxtLogRetentionDays.Text, out var retention) ? retention : 0);
    if (!retentionResult.IsValid)
    {
        ShowValidationError(retentionResult.ErrorMessage);
        return;
    }

    var sizeResult = _validationService.ValidateMaxFileSizeMb(
        int.TryParse(TxtLogMaxFileSizeMb.Text, out var size) ? size : 0);
    if (!sizeResult.IsValid)
    {
        ShowValidationError(sizeResult.ErrorMessage);
        return;
    }

    var timeoutResult = _validationService.ValidateWinRMTimeoutSeconds(
        int.TryParse(TxtWinRMTimeoutSeconds.Text, out var timeout) ? timeout : 0);
    if (!timeoutResult.IsValid)
    {
        ShowValidationError(timeoutResult.ErrorMessage);
        return;
    }

    var retryResult = _validationService.ValidateWinRMRetryCount(
        int.TryParse(TxtWinRMRetryCount.Text, out var retry) ? retry : 0);
    if (!retryResult.IsValid)
    {
        ShowValidationError(retryResult.ErrorMessage);
        return;
    }
    ```

    2. Parse ComboBox selections to enum values:

    ```csharp
    // Helper function to parse enum from ComboBox Tag
    DefaultSyncProfile ParseDefaultSyncProfile()
    {
        if (CboDefaultSyncProfile.SelectedItem is ComboBoxItem cbi && cbi.Tag is string tag)
        {
            return Enum.Parse<DefaultSyncProfile>(tag);
        }
        return DefaultSyncProfile.Full; // default
    }

    LogLevel ParseLogLevel()
    {
        if (CboLogLevel.SelectedItem is ComboBoxItem cbi && cbi.Tag is string tag)
        {
            return Enum.Parse<LogLevel>(tag);
        }
        return LogLevel.Info; // default
    }

    DashboardRefreshInterval ParseDashboardRefreshInterval()
    {
        if (CboDashboardRefreshInterval.SelectedItem is ComboBoxItem cbi && cbi.Tag is string tag)
        {
            return Enum.Parse<DashboardRefreshInterval>(tag);
        }
        return DashboardRefreshInterval.Sec30; // default
    }
    ```

    3. Update Result AppSettings creation to include new properties:

    ```csharp
    Result = new AppSettings
    {
        // Existing properties
        ServerMode = selectedMode,
        RefreshIntervalSeconds = interval,
        ContentPath = TxtContentPath.Text.Trim(),
        SqlInstance = TxtSqlInstance.Text.Trim(),
        SelectedTheme = _previewTheme,
        LogPanelExpanded = true,
        LiveTerminalMode = false,

        // New properties
        DefaultSyncProfile = ParseDefaultSyncProfile(),
        LogLevel = ParseLogLevel(),
        LogRetentionDays = int.Parse(TxtLogRetentionDays.Text),
        LogMaxFileSizeMb = int.Parse(TxtLogMaxFileSizeMb.Text),
        PersistWindowState = ChkPersistWindowState.IsChecked ?? true,
        DashboardRefreshInterval = ParseDashboardRefreshInterval(),
        RequireConfirmationDestructive = ChkRequireConfirmationDestructive.IsChecked ?? true,
        WinRMTimeoutSeconds = int.Parse(TxtWinRMTimeoutSeconds.Text),
        WinRMRetryCount = int.Parse(TxtWinRMRetryCount.Text)
    };
    ```

    4. Add helper method for validation error display:

    ```csharp
    private void ShowValidationError(string message)
    {
        MessageBox.Show(
            message,
            "Validation Error",
            MessageBoxButton.OK,
            MessageBoxImage.Warning);
    }
    ```

    DO NOT: Use ParseInt without validation - validation already checked, values are safe to parse
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    BtnSave_Click updated with validation for all 4 numeric fields, ComboBox enum parsing, all 8 new properties added to Result AppSettings
  </done>
</task>

<task type="auto">
  <name>Update MainViewModel to pass ISettingsValidationService</name>
  <files>src/WsusManager.App/ViewModels/MainViewModel.cs</files>
  <action>
    Update MainViewModel.OpenSettings method to pass the validation service:

    1. Find the OpenSettings method (around line 1571)

    2. Update the SettingsDialog instantiation to include the service:

    ```csharp
    private async Task OpenSettings()
    {
        var dialog = new SettingsDialog(_settings, _themeService, _validationService);
        // ... rest of method unchanged
    }
    ```

    3. Inject ISettingsValidationService in MainViewModel constructor if not already present:
    - Add parameter: `ISettingsValidationService validationService`
    - Add field: `private readonly ISettingsValidationService _validationService;`
    - Initialize field: `_validationService = validationService;`

    DO NOT: Break existing SettingsDialog calls - there should only be one (OpenSettings method)
  </action>
  <verify>
    dotnet build src/WsusManager.App/WsusManager.App.csproj succeeds
  </verify>
  <done>
    MainViewModel injects ISettingsValidationService and passes to SettingsDialog
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: dotnet build src/WsusManager.App
2. SettingsDialog constructor accepts ISettingsValidationService
3. All 8 new controls pre-populated from current settings
4. LostFocus validation shows red border for invalid input
5. Reset to Defaults shows confirmation and resets all controls
6. Save button validates all settings before closing
7. MainViewModel passes validation service to dialog
8. NoMessageBox on LostFocus (visual feedback only)
</verification>

<success_criteria>
SettingsDialog code-behind updated with validation logic, reset handling, and proper state management. All new controls integrated with save/load functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/28-settings-expansion/28-04-SUMMARY.md`
</output>
