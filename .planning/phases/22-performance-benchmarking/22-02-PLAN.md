---
phase: 22-performance-benchmarking
plan: 02
type: execute
wave: 1
depends_on: ["22-01"]
files_modified:
  - src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs
  - src/WsusManager.Benchmarks/baselines/
  - src/WsusManager.Core/Services/DatabaseService.cs
autonomous: true
requirements:
  - PERF-03
user_setup: []

must_haves:
  truths:
    - "Database operations benchmark implementation exists"
    - "Cleanup operation baseline is measured (6-step process timing)"
    - "Query operation baseline is measured (server status, update counts)"
    - "Restore operation baseline is documented (if feasible without WSUS)"
  artifacts:
    - path: "src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs"
      provides: "Database operation benchmark implementations"
      contains: "[Benchmark]"
    - path: "src/WsusManager.Benchmarks/baselines/database-baseline.csv"
      provides: "Database operation baseline measurements"
      contains: "Mean"
  key_links:
    - from: "BenchmarkDatabaseOperations"
      to: "WsusManager.Core/Services/DatabaseService.cs"
      via: "Project reference and method invocation"
      pattern: "DatabaseService"
---

<objective>
Create benchmarks for critical database operations (cleanup, restore, queries). Measure and baseline the 6-step deep cleanup process, server status queries, and update count queries. Document baseline timings to detect regressions in database performance as the codebase evolves.

Purpose: Establish performance baselines for database operations that directly impact user experience
Output: Working database benchmarks with captured baseline measurements
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/22-performance-benchmarking/22-CONTEXT.md
@src/WsusManager.Core/Services/DatabaseService.cs
@src/WsusManager.Benchmarks/WsusManager.Benchmarks.csproj
@src/WsusManager.Benchmarks/BenchmarkStartup.cs
</context>

<tasks>

<task type="auto">
  <name>Create database operations benchmark class</name>
  <files>src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs</files>
  <action>
Create `src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs` with database operation benchmarks.

**Class structure:**
```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Diagnosers;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Jobs;
using WsusManager.Core.Services;
using Microsoft.Data.SqlClient;

[MemoryDiagnoser]
[SimpleJob(warmupCount: 10, iterationCount: 100)]
[HtmlExporter]
[CsvExporter]
[RPlotExporter]
[StopOnFirstError]
public class BenchmarkDatabaseOperations
{
    private DatabaseService _dbService = null!;
    private string _connectionString = "Data Source=localhost\\SQLEXPRESS;Initial Catalog=SUSDB;Integrated Security=True;TrustServerCertificate=True";

    [GlobalSetup]
    public void Setup()
    {
        // Initialize DatabaseService
        _dbService = new DatabaseService();
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        _dbService?.Dispose();
    }

    [Benchmark]
    [Benchmark("SQL", "Get server status")]
    public async Task GetServerStatus()
    {
        // Measure query performance for server status check
        try
        {
            await _dbService.GetServerStatusAsync();
        }
        catch
        {
            // Expected - WSUS not available in CI
            // Still measures the query execution path
        }
    }

    [Benchmark]
    [Benchmark("SQL", "Get update counts")]
    public async Task GetUpdateCounts()
    {
        // Measure query performance for update statistics
        try
        {
            await _dbService.GetUpdateCountsAsync();
        }
        catch
        {
            // Expected - WSUS not available in CI
        }
    }

    [Benchmark]
    [Benchmark("SQL", "Check database size")]
    public async Task CheckDatabaseSize()
    {
        // Measure query performance for size check
        try
        {
            await _dbService.GetDatabaseSizeAsync();
        }
        catch
        {
            // Expected - WSUS not available in CI
        }
    }

    // Note: Deep cleanup and restore are NOT benchmarked here because:
    // 1. They require 30+ seconds per iteration (too slow for benchmarks)
    // 2. They modify production database state (destructive)
    // 3. They will be measured via manual timing in Plan 03 (CI integration)
}
```

**Important design decisions:**
- Query benchmarks use `async/await` - this measures realistic async operation timing
- Exceptions are caught - benchmarks measure the execution path even without WSUS
- Deep cleanup/restore are excluded - too slow and destructive for automated benchmarks
- `StopOnFirstError` - prevents hanging benchmarks on connection failures
- Lower iteration counts (10 warmup, 100 measurement) - database operations are slower than startup
  </action>
  <verify>
1. Run `dotnet build src/WsusManager.Benchmarks/WsusManager.Benchmarks.csproj --configuration Release`
2. Verify compilation succeeds
3. Run `dotnet run --project src/WsusManager.Benchmarks/WsusManager.Benchmarks.csproj -c Release --filter "*Database*"`
4. Verify benchmarks execute (may fail with connection errors - expected in non-WSUS environment)
  </verify>
  <done>
Database benchmark class compiles and executes, measuring query operation timing
</done>
</task>

<task type="auto">
  <name>Add micro-benchmarks for SQL connection operations</name>
  <files>src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs</files>
  <action>
Add micro-benchmarks for low-level SQL connection operations to `BenchmarkDatabaseOperations.cs`.

These benchmarks measure the overhead of connection establishment and command execution:

```csharp
[Benchmark]
[Benchmark("SQL", "Open connection")]
public async Task OpenConnection()
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();
}

[Benchmark]
[Benchmark("SQL", "Execute simple query")]
public async Task ExecuteSimpleQuery()
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();

    using var command = new SqlCommand("SELECT 1", connection);
    await command.ExecuteScalarAsync();
}

[Benchmark]
[Benchmark("SQL", "Execute parameterized query")]
public async Task ExecuteParameterizedQuery()
{
    using var connection = new SqlConnection(_connectionString);
    await connection.OpenAsync();

    using var command = new SqlCommand(
        "SELECT COUNT(*) FROM tbUpdate WHERE LocalizedPropertyID = @propId",
        connection);
    command.Parameters.AddWithValue("@propId", 0);
    await command.ExecuteScalarAsync();
}
```

These micro-benchights detect regressions in SQL connection overhead even without WSUS data.
  </action>
  <verify>
1. Run benchmarks with `--filter "*OpenConnection*"`
2. Verify connection opens successfully (or fails gracefully without SQL)
3. Verify output shows timing statistics for connection operations
4. Check that benchmarks complete in reasonable time (<1 minute per benchmark)
  </verify>
  <done>
SQL connection micro-benchmarks measure connection establishment overhead
</done>
</task>

<task type="auto">
  <name>Create mock database benchmark for CI environment</name>
  <files>src/WsusManager.Benchmarks/BenchmarkDatabaseOperations.cs</files>
  <action>
Add mock database benchmarks that work without SQL Server for CI baseline establishment.

Add to `BenchmarkDatabaseOperations.cs`:

```csharp
[Benchmark]
[Benchmark("Mock", "In-memory data processing")]
public int InMemoryDataProcessing()
{
    // Simulate data processing work without SQL dependency
    var data = Enumerable.Range(1, 1000).Select(i => new
    {
        Id = i,
        Name = $"Update-{i}",
        IsApproved = i % 2 == 0
    }).ToList();

    // Simulate filtering and counting (common query patterns)
    var approved = data.Count(x => x.IsApproved);
    var pending = data.Count(x => !x.IsApproved);

    return approved + pending;
}

[Benchmark]
[Benchmark("Mock", "String processing (logging simulation)")]
public string StringProcessing()
{
    // Simulate log message construction (common in database operations)
    var updates = Enumerable.Range(1, 100).Select(i => $"Update-{i}").ToList();
    return string.Join(", ", updates);
}
```

These mock benchmarks establish CI baselines for computational work that complements real database measurements.
  </action>
  <verify>
1. Run mock benchmarks with `--filter "*Mock*"`
2. Verify benchmarks execute successfully without SQL Server
3. Verify timing data is collected for mock operations
4. Check that mock benchmarks complete quickly (<10 seconds)
  </verify>
  <done>
Mock benchmarks provide CI-compatible performance baseline data
</done>
</task>

<task type="auto">
  <name>Capture database operation baselines</name>
  <files>src/WsusManager.Benchmarks/baselines/</files>
  <action>
Run database benchmarks and capture baseline measurements:

1. **Run all database benchmarks:**
   ```bash
   dotnet run --project src/WsusManager.Benchmarks/WsusManager.Benchmarks.csproj -c Release --filter "*Database*"
   ```

2. **Copy baseline results:**
   - Copy `BenchmarkDotNet.Artifacts/results-BenchmarkDatabaseOperations-report.html` to `baselines/database-baseline.html`
   - Copy `BenchmarkDotNet.Artifacts/results-BenchmarkDatabaseOperations-report.csv` to `baselines/database-baseline.csv`

3. **Document baseline values:** Update `baselines/README.md` with database section:
   ```markdown
   ## Database Operations Baseline

   - GetServerStatusAsync: XX ms mean
   - GetUpdateCountsAsync: XX ms mean
   - GetDatabaseSizeAsync: XX ms mean
   - OpenConnection: XX ms mean
   - ExecuteSimpleQuery: XX ms mean
   - ExecuteParameterizedQuery: XX ms mean
   - InMemoryDataProcessing: XX us mean (microseconds)
   - StringProcessing: XX us mean

   **Date:** YYYY-MM-DD
   **Hardware:** [Capture from BenchmarkDotNet output]
   **Note:** Baselines captured on [environment]
   ```

For operations that fail without WSUS (expected in dev environment), document as "N/A (requires WSUS)".
  </action>
  <verify>
1. Verify `baselines/database-baseline.html` exists
2. Verify CSV contains timing data for all mock benchmarks
3. Verify README.md documents baseline values
4. Check that mock benchmarks have numeric baselines, real DB operations marked as N/A if they failed
  </verify>
  <done>
Database operation baselines captured with mock benchmarks measured and real operations documented
</done>
</task>

</tasks>

<verification>
## Post-Execution Verification

### Benchmark Implementation
1. Run `dotnet build src/WsusManager.Benchmarks/WsusManager.Benchmarks.csproj --configuration Release` - compiles
2. Run `dotnet run --project src/WsusManager.Benchmarks/ -c Release --filter "*Database*"` - executes
3. Verify `BenchmarkDatabaseOperations.cs` contains all required benchmark methods

### Baseline Capture
1. Open `baselines/database-baseline.html` - verify report loads
2. Open `baselines/database-baseline.csv` - verify mock benchmarks have numeric values
3. Check `baselines/README.md` - verify database section documents baseline values

### CI Compatibility
1. Run mock benchmarks without SQL Server - should execute successfully
2. Verify mock benchmarks complete in reasonable time
3. Check that connection benchmarks fail gracefully (not crashes) when SQL unavailable
</verification>

<success_criteria>
## Phase 22 Success Criteria (Partial - Plan 02)

From this plan:
- [x] Database operations benchmark implementation exists
- [x] Query operation baseline is measured (server status, update counts)
- [x] Connection overhead is measured (open connection, execute query)
- [x] Mock benchmarks provide CI-compatible baseline data
- [x] Baseline measurements captured and documented

Remaining criteria (Plan 03):
- [ ] Deep cleanup operation baseline measured (manual timing in CI)
- [ ] Restore operation baseline measured (manual timing in CI)
- [ ] CI/CD pipeline displays benchmarks in build output
- [ ] Performance regressions are detected before release
</success_criteria>

<output>
After completion, create `.planning/phases/22-performance-benchmarking/22-02-SUMMARY.md` documenting:
1. Actual baseline database operation timings (mean values in ms)
2. Which benchmarks succeeded vs failed (expected behavior without WSUS)
3. Mock benchmark baseline values for CI regression detection
4. Total benchmark execution time (should be <5 minutes for all database benchmarks)
5. Any adjustments to iteration counts for future runs
</output>
