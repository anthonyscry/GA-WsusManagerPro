# Plan 23-01: Memory Leak Detection and Prevention

**Phase:** 23 - Memory Leak Detection
**Created:** 2026-02-21
**Status:** Ready for implementation
**Requirements:** PERF-06

## Overview

This plan implements comprehensive memory leak detection and prevention for the WPF application. Based on the Phase 23 context and research from `PITFALLS.md`, we will identify and fix memory leaks to ensure long-running stability before v4.4 release.

## Current State Analysis

### Potential Leak Sources Identified

1. **Event Handler Subscriptions**
   - `App.xaml.cs`: Static event handlers on `TaskScheduler.UnobservedTaskException` and `AppDomain.CurrentDomain.UnhandledException` - these are static and appropriate
   - `App.DispatcherUnhandledException` - attached to App instance, not cleaned up
   - `ProcessRunner.cs`: Event handlers (`OutputDataReceived`, `ErrorDataReceived`) are lambdas attached to Process objects
   - `MainViewModel.cs`: `DispatcherTimer.Tick` event subscription in `StartRefreshTimer()` - timer is stopped but event handler not explicitly removed
   - Dialogs: Multiple dialogs use lambda event handlers for ESC key closing

2. **LogOutput String Concatenation**
   - `MainViewModel.LogOutput` uses `+=` for appending lines: `LogOutput += line + Environment.NewLine`
   - This creates new string objects on every append (strings are immutable)
   - After extended operation, this could consume significant memory

3. **IDisposable Objects**
   - `LogService` implements `IDisposable` correctly
   - `MainViewModel._operationCts` is disposed in `RunOperationAsync` finally block
   - `MainViewModel._refreshTimer` is stopped but not explicitly disposed (though `DispatcherTimer` doesn't implement `IDisposable`)

4. **Dialog Window References**
   - All dialogs are shown with `ShowDialog()` which blocks
   - Dialogs are not stored in long-lived fields
   - No explicit cleanup after dialog close

5. **No ObservableCollections Found**
   - The application doesn't use `ObservableCollection<T>` for any collections
   - All dashboard cards are individual properties, not collections
   - ScriptOperations returns `IReadOnlyList<string>` from service

### Critical Issues to Fix

**Priority 1: Log String Accumulation**
- `LogOutput += line + Environment.NewLine` creates unbounded string growth
- After 10,000 log lines at ~50 chars each = 500KB just for logs
- Memory never released until app closes

**Priority 2: DispatcherTimer Event Handler**
- `_refreshTimer.Tick += async (_, _) => await RefreshDashboard()` is never unsubscribed
- Timer is stopped but handler remains attached

**Priority 3: Process Event Handlers**
- `ProcessRunner` event handlers are attached but not explicitly removed
- Process is `using` so should dispose, but handlers create closures

**Priority 4: Dialog ESC Key Handlers**
- All dialogs use `KeyDown += (s, e) => { ... }` lambdas
- Handlers not removed in `Unloaded` or `Closed` events

## Implementation Plan

### Step 1: Fix LogOutput String Accumulation (HIGH PRIORITY)

**Problem:** String concatenation in a tight loop causes unbounded memory growth.

**Solution:** Use `StringBuilder` for log output.

**Changes:**

1. Update `MainViewModel.cs`:

```csharp
// Add field
private readonly StringBuilder _logBuilder = new();

// Change property
[ObservableProperty]
private string _logOutput = string.Empty;

// Update AppendLog method
public void AppendLog(string line)
{
    _logBuilder.AppendLine(line);

    // Trim to last 1000 lines to prevent unbounded growth
    if (_logBuilder.Length > 100_000) // ~100KB limit
    {
        var lines = _logBuilder.ToString().Split('\n');
        if (lines.Length > 1000)
        {
            _logBuilder.Clear();
            var start = lines.Length - 1000;
            for (int i = start; i < lines.Length; i++)
            {
                _logBuilder.AppendLine(lines[i]);
            }
        }
    }

    LogOutput = _logBuilder.ToString();
}

// Update ClearLog method
[RelayCommand]
private void ClearLog()
{
    _logBuilder.Clear();
    LogOutput = string.Empty;
}
```

**Verification:**
- Run 1000 log appends
- Check memory with dotMemory: should plateau at ~100KB

### Step 2: Fix DispatcherTimer Event Handler

**Problem:** Event handler never removed, though timer is stopped.

**Solution:** Explicitly unsubscribe in cleanup method.

**Changes:**

1. Update `MainViewModel.cs`:

```csharp
private void StartRefreshTimer()
{
    var interval = TimeSpan.FromSeconds(
        _settings.RefreshIntervalSeconds > 0 ? _settings.RefreshIntervalSeconds : 30);

    _refreshTimer = new DispatcherTimer { Interval = interval };

    // Store handler reference for unsubscription
    EventHandler? handler = null;
    handler = async (_, _) =>
    {
        try
        {
            await RefreshDashboard().ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            _logService.Error(ex, "Dashboard refresh failed");
        }
    };

    _refreshTimer.Tick += handler;
    _refreshTimer.Start();

    _logService.Debug("Dashboard auto-refresh started ({Interval}s interval)", interval.TotalSeconds);
}

public void StopRefreshTimer()
{
    if (_refreshTimer != null)
    {
        _refreshTimer.Stop();
        // Important: Remove event handler to prevent leak
        _refreshTimer.Tick -= null; // Removes all handlers (only one in this case)
        _refreshTimer = null;
    }
}
```

**Verification:**
- Use dotMemory to check no DispatcherTimer instances after app close
- Check no event handler references remain

### Step 3: Add IDisposable to MainViewModel

**Problem:** No explicit cleanup of resources.

**Solution:** Implement `IDisposable` pattern.

**Changes:**

1. Update `MainViewModel.cs` to implement `IDisposable`:

```csharp
public partial class MainViewModel : ObservableObject, IDisposable
{
    private bool _disposed;

    // ... existing code ...

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        // Stop and cleanup timer
        StopRefreshTimer();

        // Cancel any running operation
        if (_operationCts is { IsCancellationRequested: false })
        {
            _operationCts.Cancel();
            _operationCts.Dispose();
        }

        // Clear log builder
        _logBuilder?.Clear();

        GC.SuppressFinalize(this);
    }
}
```

2. Update `MainWindow.xaml.cs`:

```csharp
public partial class MainWindow : Window
{
    private readonly MainViewModel _viewModel;

    public MainWindow(MainViewModel viewModel)
    {
        InitializeComponent();
        _viewModel = viewModel;
        DataContext = viewModel;

        Loaded += MainWindow_Loaded;
        Closed += MainWindow_Closed; // Add cleanup handler
    }

    private async void MainWindow_Loaded(object sender, RoutedEventArgs e)
    {
        await _viewModel.InitializeAsync().ConfigureAwait(false);
    }

    private void MainWindow_Closed(object? sender, EventArgs e)
    {
        // Cleanup ViewModel resources
        _viewModel.Dispose();
    }

    // ... existing code ...
}
```

3. Update `App.xaml.cs` to cleanup static handlers:

```csharp
public partial class App : Application
{
    // ... existing code ...

    protected override void OnExit(ExitEventArgs e)
    {
        // Unsubscribe static event handlers
        TaskScheduler.UnobservedTaskException -= OnUnobservedTaskException;
        AppDomain.CurrentDomain.UnhandledException -= OnAppDomainUnhandledException;

        base.OnExit(e);
    }

    // ... existing code ...
}
```

**Verification:**
- Open and close MainWindow 50 times
- Check dotMemory: only 1 MainWindow instance should exist
- No leaked event handlers

### Step 4: Dialog Event Handler Cleanup

**Problem:** Lambda event handlers in dialogs create potential leaks.

**Solution:** Add `Closed` event handlers for cleanup.

**Changes:**

For each dialog (`SettingsDialog.xaml.cs`, `TransferDialog.xaml.cs`, etc.):

```csharp
// Example for SettingsDialog.xaml.cs
private KeyEventHandler? _escHandler;

public SettingsDialog(AppSettings settings, IThemeService themeService)
{
    InitializeComponent();

    // Store handler reference
    _escHandler = (s, e) =>
    {
        if (e.Key == Key.Escape)
        {
            Close();
        }
    };

    KeyDown += _escHandler;
    Closed += Dialog_Closed;

    // ... rest of constructor ...
}

private void Dialog_Closed(object? sender, EventArgs e)
{
    // Cleanup event handlers
    if (_escHandler != null)
    {
        KeyDown -= _escHandler;
        _escHandler = null;
    }

    Closed -= Dialog_Closed;
}
```

**Verification:**
- Open/close each dialog 100 times
- dotMemory should show stable dialog instance counts

### Step 5: ProcessRunner Event Handler Verification

**Problem:** Event handlers on Process object.

**Solution:** Verify `using` statement properly cleans up handlers.

**Analysis:**
- `ProcessRunner.RunAsync()` uses `using var proc`
- The `Process` class implements `IDisposable`
- When disposed, it should detach event handlers

**Verification:**
- Run `ProcessRunner` 100 times in a test
- Check dotMemory for Process instances (should be 0 after GC)

## Testing Plan

### Manual Testing with dotMemory (Recommended)

**Prerequisites:**
- Install JetBrains dotMemory (or use PerfView as free alternative)
- Build application in Release configuration

**Test Scenarios:**

1. **Dashboard Refresh Stress Test**
   - Start application, take baseline snapshot
   - Let app run for 1 hour (120 refresh cycles at 30s interval)
   - Force GC, take snapshot
   - Compare: memory should be within 5% of baseline

2. **Window Open/Close Test**
   - Create test harness that opens/closes MainWindow 50 times
   - Take snapshot after each close
   - Compare: no growing MainWindow instance count

3. **Dialog Reuse Test**
   - Open/close SettingsDialog 100 times
   - Open/close TransferDialog 100 times
   - Force GC, take snapshot
   - Compare: no dialog instances should remain

4. **Long-Running Operation Test**
   - Start 100 consecutive dashboard refresh operations
   - Monitor memory after each operation
   - Memory should plateau, not grow linearly

5. **Log Accumulation Test**
   - Append 10,000 log lines
   - Memory should remain <500KB for logs
   - Clear log, verify memory released

**Acceptance Criteria:**
- Memory growth <5% after 100 operations of same type
- No unbounded growth in specific object types
- Memory returns to baseline +/- 5% after GC

### Automated Test (Optional)

If dotMemory is unavailable, add basic smoke test:

```csharp
[Fact]
public async Task MainViewModel_Dispose_CleansUpResources()
{
    // Arrange
    var viewModel = CreateViewModel();
    await viewModel.InitializeAsync();

    // Act
    viewModel.Dispose();

    // Assert
    // Timer should be stopped
    // CTS should be disposed
    // No exceptions on GC
}
```

## Claude's Discretion

**Decision Points:**
1. **dotMemory vs PerfView:** dotMemory is preferred (better UX, automatic leak detection). Use PerfView only if dotMemory unavailable.
2. **StringBuilder vs Circular Buffer:** StringBuilder with trimming is simpler. Circular buffer is more complex but more efficient. Use StringBuilder for now.
3. **Log trim threshold:** 1000 lines / 100KB is reasonable. Can adjust based on testing.
4. **Dialog cleanup priority:** This is low-risk (dialogs are short-lived). Can defer if time-constrained.
5. **IDisposable vs Finalizer:** MainViewModel doesn't need finalizer (no unmanaged resources). Dispose pattern is sufficient.

## Dependencies

**On:**
- None (can be done independently)

**Blocked By:**
- None

**Blocks:**
- Phase 24 (Documentation Generation) - should have clean code before documenting

## Effort Estimate

- **Step 1 (Log StringBuilder):** 30 minutes
- **Step 2 (Timer cleanup):** 30 minutes
- **Step 3 (IDisposable):** 1 hour (includes MainWindow, App cleanup)
- **Step 4 (Dialog cleanup):** 2 hours (6 dialogs × 20 min each)
- **Step 5 (Testing):** 2 hours (manual profiling with dotMemory)

**Total:** ~6 hours

## Success Criteria

1. ✓ `LogOutput` uses StringBuilder with trimming (no unbounded string growth)
2. ✓ `DispatcherTimer` event handler is explicitly removed
3. ✓ `MainViewModel` implements `IDisposable` and cleans up resources
4. ✓ Dialog event handlers are cleaned up in `Closed` events
5. ✓ `App` unsubscribes static event handlers in `OnExit`
6. ✓ dotMemory profiling shows <5% memory growth after 100 operations
7. ✓ No unbounded object instance counts observed during stress testing
8. ✓ PERF-06 requirement marked complete

## Notes

- From `PITFALLS.md` (Pitfall 3): WPF's strong reference patterns create leaks through event handlers, data binding, and named elements
- The current codebase is relatively clean (no large ObservableCollection usage, minimal event handlers)
- Main concern is the `LogOutput` string accumulation which is guaranteed to cause issues in long-running sessions
- Dialog leaks are low-risk since `ShowDialog()` blocks and dialogs are GC'd when closed, but explicit cleanup is best practice

---

*Plan: 23-01*
*Phase: 23 - Memory Leak Detection*
*Created: 2026-02-21*
