---
phase: 14-client-management-core
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/WsusManager.Core/Services/ClientService.cs
  - src/WsusManager.Tests/Services/ClientServiceTests.cs
autonomous: true
requirements: [CLI-01, CLI-02, CLI-04, CLI-05]

must_haves:
  truths:
    - "CancelStuckJobs stops wuauserv/bits, clears SoftwareDistribution, restarts services on the remote host"
    - "ForceCheckIn runs gpupdate, wuauclt resetauthorization/detectnow/reportnow on the remote host"
    - "TestConnectivity checks TCP ports 8530 and 8531 from the remote host to the WSUS server"
    - "RunDiagnostics returns WSUS settings, service status, last check-in time, and pending reboot state"
    - "All operations report step-by-step progress via IProgress<string>"
    - "WinRM failures produce clear error messages, not exceptions"
  artifacts:
    - path: "src/WsusManager.Core/Services/ClientService.cs"
      provides: "Implementation of all 5 IClientService operations"
      exports: ["ClientService"]
    - path: "src/WsusManager.Tests/Services/ClientServiceTests.cs"
      provides: "Unit tests for ClientService with mocked WinRmExecutor"
      min_lines: 100
  key_links:
    - from: "ClientService"
      to: "WinRmExecutor"
      via: "constructor injection"
      pattern: "_executor.ExecuteRemoteAsync"
    - from: "ClientService"
      to: "WsusErrorCodes"
      via: "static lookup call"
      pattern: "WsusErrorCodes.Lookup"
    - from: "ClientServiceTests"
      to: "ClientService"
      via: "xUnit tests with Moq"
      pattern: "Mock<IProcessRunner>"
---

<objective>
Implement all 5 client management operations and comprehensive unit tests.

Purpose: Provides the working service layer that the GUI (Plan 03) will call. Each operation maps directly to a phase requirement (CLI-01 through CLI-06).

Output: ClientService.cs with all operations, ClientServiceTests.cs with tests.
</objective>

<execution_context>
@/home/anthonyscry/.claude/get-shit-done/workflows/execute-plan.md
@/home/anthonyscry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-client-management-core/14-01-SUMMARY.md
@Scripts/Invoke-WsusClientCheckIn.ps1
@src/WsusManager.Core/Services/SyncService.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ClientService with all 5 operations</name>
  <files>
    src/WsusManager.Core/Services/ClientService.cs
  </files>
  <action>
Create `ClientService : IClientService` with constructor taking `WinRmExecutor` and `ILogService`.

**CancelStuckJobsAsync (CLI-01):**
Remote script block (3 steps, report progress for each):
1. Stop services: `Stop-Service wuauserv, bits -Force -ErrorAction SilentlyContinue`
2. Clear cache: `Remove-Item 'C:\Windows\SoftwareDistribution\*' -Recurse -Force -ErrorAction SilentlyContinue`
3. Restart services: `Start-Service bits, wuauserv -ErrorAction Stop`

Report: `[Step 1/3] Stopping Windows Update services on {hostname}...` etc.
Use a single Invoke-Command with all 3 steps in the script block (minimizes WinRM round trips).
Parse output lines and report via progress.

**ForceCheckInAsync (CLI-02):**
Remote script block (4 steps):
1. `gpupdate /force` — refresh Group Policy
2. `wuauclt /resetauthorization` — reset WSUS client identity
3. `wuauclt /detectnow` — force update detection
4. `wuauclt /reportnow` — force status report to WSUS server

Report: `[Step 1/4] Running gpupdate /force on {hostname}...` etc.

**TestConnectivityAsync (CLI-04):**
Remote script block — test TCP connection from client to WSUS server:
```powershell
$server = '{wsusServerHostname}'
$r8530 = Test-NetConnection -ComputerName $server -Port 8530 -WarningAction SilentlyContinue
$r8531 = Test-NetConnection -ComputerName $server -Port 8531 -WarningAction SilentlyContinue
"PORT8530=$($r8530.TcpTestSucceeded);PORT8531=$($r8531.TcpTestSucceeded);LATENCY=$($r8530.PingReplyDetails.RoundtripTime)"
```

Parse the WSUS server hostname from the `wsusServerUrl` parameter (strip `http://` or `https://` and port).
Parse output into `ConnectivityTestResult`. Report results with pass/fail formatting.

**RunDiagnosticsAsync (CLI-05):**
Remote script block — gather all diagnostic info in one round trip:
```powershell
$wu = Get-ItemProperty 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate' -EA SilentlyContinue
$au = Get-ItemProperty 'HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU' -EA SilentlyContinue
$svcs = Get-Service wuauserv, bits, cryptsvc -EA SilentlyContinue | ForEach-Object { "$($_.Name)=$($_.Status)" }
$reboot = Test-Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired'
$lastReport = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate' -Name LastWUStatusReportTime -EA SilentlyContinue).LastWUStatusReportTime
$agent = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update' -Name AgentVersion -EA SilentlyContinue).AgentVersion
"WSUS=$($wu.WUServer);STATUS=$($wu.WUStatusServer);USE=$($au.UseWUServer);SVCS=$($svcs -join ',');REBOOT=$reboot;LASTCHECKIN=$lastReport;AGENT=$agent"
```

Parse output into `ClientDiagnosticResult`. Report each field clearly.

**LookupErrorCode (CLI-06):**
Simply delegate to `WsusErrorCodes.Lookup(errorCode)`. Return `OperationResult<WsusErrorInfo>.Ok(info)` if found, `Fail("Error code not found")` if not.

**Design notes:**
- Each remote operation should first call `_executor.TestWinRmAsync()` and return early with a clear failure if WinRM is not available
- All script blocks should use `-ErrorAction SilentlyContinue` for registry reads (not all keys exist on all clients)
- Use single-line output format (KEY=VALUE;KEY=VALUE) to simplify parsing from ProcessResult output lines
  </action>
  <verify>
Build: `dotnet build src/WsusManager.Core/WsusManager.Core.csproj`
Verify: ClientService compiles, implements all 5 IClientService methods.
  </verify>
  <done>ClientService implements all 5 operations with step-by-step progress reporting. Remote operations use single-round-trip script blocks. WinRM availability is checked before each remote operation. Error code lookup is local and synchronous.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for ClientService</name>
  <files>
    src/WsusManager.Tests/Services/ClientServiceTests.cs
  </files>
  <action>
Create xUnit tests following the existing test patterns (e.g., ContentResetServiceTests). Use Moq for IProcessRunner and ILogService.

**Test structure:**
- Create a mock WinRmExecutor by mocking the IProcessRunner it depends on
- Helper methods: `SuccessResult(string output)` and `FailResult(string output)` returning ProcessResult

**Required tests (minimum 10):**

1. `CancelStuckJobs_Returns_Success_When_Remote_Succeeds` — mock successful exit code, verify OperationResult.Success
2. `CancelStuckJobs_Returns_Failure_When_WinRm_Unavailable` — mock Test-WSMan failure, verify failure message mentions WinRM
3. `ForceCheckIn_Returns_Success_When_Remote_Succeeds`
4. `ForceCheckIn_Reports_Step_Progress` — verify progress.Report called with "[Step" prefix
5. `TestConnectivity_Parses_Port_Results_Correctly` — mock output with "PORT8530=True;PORT8531=False;LATENCY=5", verify ConnectivityTestResult
6. `TestConnectivity_Returns_Failure_When_WinRm_Unavailable`
7. `RunDiagnostics_Parses_Registry_Values_Correctly` — mock output with known values, verify ClientDiagnosticResult fields
8. `RunDiagnostics_Handles_Missing_Registry_Keys` — mock output with empty values, verify no crash
9. `LookupErrorCode_Returns_Known_Code` — lookup 0x80072EE2, verify description contains "timeout" or "connect"
10. `LookupErrorCode_Returns_Failure_For_Unknown_Code` — lookup 0xDEADBEEF, verify OperationResult.Success is false
11. `CancelStuckJobs_Validates_Hostname` — pass empty hostname, verify failure without remote call
12. `TestConnectivity_Extracts_Server_From_Url` — verify http://wsus01:8530 extracts "wsus01"

Follow the existing pattern: `private readonly Mock<IProcessRunner> _mockRunner = new();` and `CreateService()` helper.
  </action>
  <verify>
Build and test: `dotnet test src/WsusManager.Tests/WsusManager.Tests.csproj --filter "FullyQualifiedName~ClientServiceTests" --verbosity normal`
Verify: All tests pass.
  </verify>
  <done>12+ unit tests cover all 5 operations including success paths, WinRM failures, output parsing, hostname validation, and error code lookup. All tests pass.</done>
</task>

</tasks>

<verification>
1. `dotnet build src/WsusManager.Core/WsusManager.Core.csproj` — no errors
2. `dotnet test src/WsusManager.Tests/ --verbosity normal` — all tests pass including new ClientServiceTests
3. ClientService implements all 5 IClientService methods
4. Each remote operation checks WinRM availability first
5. Tests verify output parsing for connectivity and diagnostics results
</verification>

<success_criteria>
ClientService fully implements CLI-01, CLI-02, CLI-04, CLI-05 with WinRM remote execution, and CLI-06 with local error code lookup. 12+ unit tests pass. All operations report step-by-step progress and handle WinRM failures gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/14-client-management-core/14-02-SUMMARY.md`
</output>
