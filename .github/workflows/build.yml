name: Build GA-WsusManager

on:
  push:
    branches: [ main, master, develop ]
    paths:
      - 'Scripts/**'
      - 'Modules/**'
      - 'Tests/**'
      - 'build/**'
      - '*.ps1'
      - '.github/workflows/build.yml'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 3.8.0)'
        required: false
        default: ''
      create_release:
        description: 'Create GitHub release'
        required: false
        type: boolean
        default: false
      skip_tests:
        description: 'Skip tests (manual dispatch only)'
        required: false
        type: boolean
        default: false

# Prevent concurrent runs - cancel in-progress runs when new commit arrives
concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  DEFAULT_VERSION: '3.8.6'

jobs:
  #############################################
  # PowerShell Code Review
  #############################################
  code-review:
    name: PowerShell Code Review
    runs-on: windows-latest
    if: ${{ !(github.event.inputs.skip_tests == 'true' && github.event_name == 'workflow_dispatch') }}
    env:
      CI_LOG_ROOT: .\.ci-artifacts\legacy\code-review

    steps:
    - name: Checkout repository
      uses: actions/checkout@v6


    - name: Record CI context & prepare diagnostics
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $context = @{
          Workflow = "${{ github.workflow }}"
          Job = "${{ github.job }}"
          Event = "${{ github.event_name }}"
          Runner = "${{ runner.name }}"
          Ref = "${{ github.ref }}"
          SHA = "${{ github.sha }}"
        }

        $summaryLines = @(
          '## CI Context',
          "* Workflow: $($context.Workflow)",
          "* Job: $($context.Job)",
          "* Event: $($context.Event)",
          "* Runner: $($context.Runner)",
          "* Ref: $($context.Ref)",
          "* SHA: $($context.SHA)"
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY
        New-Item -ItemType Directory -Path $env:CI_LOG_ROOT -Force | Out-Null

    - name: Install PSScriptAnalyzer
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        .\build\Install-ModuleWithRetry.ps1 -ModuleName PSScriptAnalyzer -MinimumVersion 1.21.0
        Get-Module -Name PSScriptAnalyzer -ListAvailable | Select-Object Name, Version

    - name: Run PSScriptAnalyzer
      id: lint
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $analyzerLog = Join-Path $diagRoot 'analyzer-log.txt'
        $analyzerJson = Join-Path $diagRoot 'analyzer-results.json'
        $summaryLog = Join-Path $diagRoot 'analyzer-summary.txt'

        Write-Host "=== Running PSScriptAnalyzer ===" -ForegroundColor Cyan
        "=== Running PSScriptAnalyzer ===" | Add-Content -Path $analyzerLog

        $results = @()
        $settingsPath = ".\.PSScriptAnalyzerSettings.psd1"

        # Analyze all PowerShell files
        $psFiles = Get-ChildItem -Path . -Include *.ps1, *.psm1, *.psd1 -Recurse -File |
                   Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\|\\dist\\' }

        Write-Host "Found $($psFiles.Count) PowerShell files to analyze"
        "Found $($psFiles.Count) PowerShell files to analyze" | Add-Content -Path $analyzerLog

        $analyzerParams = @{
          Severity = @('Error', 'Warning')
        }
        if (Test-Path $settingsPath) {
          $analyzerParams.Settings = $settingsPath
        }

        foreach ($file in $psFiles) {
          try {
            $fileResults = Invoke-ScriptAnalyzer -Path $file.FullName @analyzerParams -ErrorAction SilentlyContinue
            if ($fileResults) {
              $results += $fileResults
            }
          } catch {
            Write-Host "Skipped: $($file.Name) (analyzer error)" -ForegroundColor Yellow
            "Skipped: $($file.Name) (analyzer error)" | Add-Content -Path $analyzerLog
          }
        }

        # Output results
        $errors = $results | Where-Object { $_.Severity -eq 'Error' }
        $warnings = $results | Where-Object { $_.Severity -eq 'Warning' }

        Write-Host ""
        Write-Host "=== Results ===" -ForegroundColor Cyan
        Write-Host "Errors: $($errors.Count)" -ForegroundColor $(if ($errors.Count -gt 0) { 'Red' } else { 'Green' })
        Write-Host "Warnings: $($warnings.Count)" -ForegroundColor $(if ($warnings.Count -gt 0) { 'Yellow' } else { 'Green' })

        $results | ConvertTo-Json -Depth 6 | Out-File -FilePath $analyzerJson -Encoding utf8
        @(
          "Errors: $($errors.Count)",
          "Warnings: $($warnings.Count)"
        ) | Out-File -FilePath $summaryLog -Encoding utf8

        if ($results.Count -gt 0) {
          Write-Host ""
          Write-Host "=== Issues Found ===" -ForegroundColor Yellow
          $results | Group-Object ScriptName | ForEach-Object {
            Write-Host ""
            Write-Host "File: $($_.Name)" -ForegroundColor White
            $_.Group | ForEach-Object {
              $color = if ($_.Severity -eq 'Error') { 'Red' } else { 'Yellow' }
              Write-Host "  Line $($_.Line): [$($_.Severity)] $($_.RuleName)" -ForegroundColor $color
            }
          }
        }

        echo "WARNINGS=$($warnings.Count)" >> $env:GITHUB_OUTPUT
        echo "ERRORS=$($errors.Count)" >> $env:GITHUB_OUTPUT

        if ($errors.Count -gt 0) {
          Write-Host ""
          Write-Host "::error::PSScriptAnalyzer found $($errors.Count) error(s)"
          exit 1
        }

    - name: Security Scan
      id: security
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $securityLog = Join-Path $diagRoot 'security-log.txt'
        $securityJson = Join-Path $diagRoot 'security-issues.json'

        Write-Host "=== Running Security Analysis ===" -ForegroundColor Cyan
        "=== Running Security Analysis ===" | Add-Content -Path $securityLog

        $securityRules = @(
          'PSAvoidUsingPlainTextForPassword',
          'PSAvoidUsingConvertToSecureStringWithPlainText',
          'PSAvoidUsingInvokeExpression',
          'PSAvoidGlobalVars',
          'PSAvoidUsingEmptyCatchBlock'
        )

        $psFiles = Get-ChildItem -Path . -Include *.ps1, *.psm1 -Recurse -File |
                   Where-Object { $_.FullName -notmatch '\\Tests\\|\\\.git\\|\\dist\\' }

        $securityIssues = @()

        foreach ($file in $psFiles) {
          try {
            $issues = Invoke-ScriptAnalyzer -Path $file.FullName -IncludeRule $securityRules -ErrorAction SilentlyContinue
            if ($issues) {
              $securityIssues += $issues
            }
          } catch {
            # Skip files that cause analyzer errors
          }
        }

        Write-Host "Security Issues: $($securityIssues.Count)"
        "Security Issues: $($securityIssues.Count)" | Add-Content -Path $securityLog
        $securityIssues | Select-Object ScriptName, Line, RuleName, Severity, Message | ConvertTo-Json -Depth 6 | Out-File -FilePath $securityJson -Encoding utf8
        echo "SECURITY_ISSUES=$($securityIssues.Count)" >> $env:GITHUB_OUTPUT

        if ($securityIssues.Count -gt 0) {
          $securityIssues | ForEach-Object {
            $line = "[$($_.Severity)] $($_.ScriptName):$($_.Line) - $($_.RuleName)"
            Write-Host $line -ForegroundColor Yellow
            $line | Add-Content -Path $securityLog
          }
        }

    - name: Upload code-review diagnostics
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: code-review-diagnostics
        path: ./.ci-artifacts/legacy/code-review/*
        if-no-files-found: warn
        retention-days: 7

    - name: Code review summary
      if: always()
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $lintErrors = '${{ steps.lint.outputs.ERRORS }}'
        $lintWarnings = '${{ steps.lint.outputs.WARNINGS }}'
        $securityIssues = '${{ steps.security.outputs.SECURITY_ISSUES }}'

        $summaryLines = @(
          '',
          '## Job Summary',
          "* PSScriptAnalyzer errors: $lintErrors",
          "* PSScriptAnalyzer warnings: $lintWarnings",
          "* Security issues: $securityIssues",
          '* Diagnostics: .ci-artifacts/legacy/code-review'
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY

  #############################################
  # Pester Tests
  #############################################
  test:
    name: Pester Tests
    runs-on: windows-latest
    if: ${{ !(github.event.inputs.skip_tests == 'true' && github.event_name == 'workflow_dispatch') }}
    env:
      CI_LOG_ROOT: .\.ci-artifacts\legacy\test

    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Record CI context & prepare diagnostics
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $context = @{
          Workflow = "${{ github.workflow }}"
          Job = "${{ github.job }}"
          Event = "${{ github.event_name }}"
          Runner = "${{ runner.name }}"
          Ref = "${{ github.ref }}"
          SHA = "${{ github.sha }}"
        }

        $summaryLines = @(
          '## CI Context',
          "* Workflow: $($context.Workflow)",
          "* Job: $($context.Job)",
          "* Event: $($context.Event)",
          "* Runner: $($context.Runner)",
          "* Ref: $($context.Ref)",
          "* SHA: $($context.SHA)"
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY
        New-Item -ItemType Directory -Path $env:CI_LOG_ROOT -Force | Out-Null

    - name: Install Pester
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        .\build\Install-ModuleWithRetry.ps1 -ModuleName Pester -MinimumVersion 5.0.0
        Get-Module -Name Pester -ListAvailable | Select-Object Name, Version

    - name: Run Pester Tests
      id: pester
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $pesterLog = Join-Path $diagRoot 'pester-summary.txt'

        Write-Host "=== Running Pester Tests ===" -ForegroundColor Cyan

        # Exclude ExeValidation.Tests.ps1 - those tests require the exe which is built AFTER tests run
        $testFiles = Get-ChildItem -Path ./Tests -Filter "*.Tests.ps1" -ErrorAction SilentlyContinue |
          Where-Object { $_.Name -ne "ExeValidation.Tests.ps1" }

        if (-not $testFiles -or $testFiles.Count -eq 0) {
          Write-Host "No test files found" -ForegroundColor Yellow
          "No test files found" | Add-Content -Path $pesterLog
          echo "TESTS_RUN=0" >> $env:GITHUB_OUTPUT
          echo "TESTS_PASSED=0" >> $env:GITHUB_OUTPUT
          echo "TESTS_FAILED=0" >> $env:GITHUB_OUTPUT
          exit 0
        }

        Write-Host "Found $($testFiles.Count) test file(s)"

        Import-Module Pester -MinimumVersion 5.0.0 -Force

        $config = New-PesterConfiguration
        $config.Run.Path = $testFiles.FullName
        $config.Run.Exit = $false
        $config.Run.PassThru = $true
        $config.Output.Verbosity = 'Detailed'
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputPath = './test-results.xml'
        $config.TestResult.OutputFormat = 'NUnitXml'

        $results = Invoke-Pester -Configuration $config
        if (-not $results) {
          Write-Host "::error::Invoke-Pester did not return results"
          exit 1
        }

        Write-Host ""
        Write-Host "=== Test Summary ===" -ForegroundColor Cyan
        Write-Host "Total: $($results.TotalCount)"
        Write-Host "Passed: $($results.PassedCount)" -ForegroundColor Green
        Write-Host "Failed: $($results.FailedCount)" -ForegroundColor $(if ($results.FailedCount -gt 0) { 'Red' } else { 'Green' })

        @(
          "Total: $($results.TotalCount)",
          "Passed: $($results.PassedCount)",
          "Failed: $($results.FailedCount)",
          "Results XML: ./test-results.xml"
        ) | Out-File -FilePath $pesterLog -Encoding utf8

        echo "TESTS_RUN=$($results.TotalCount)" >> $env:GITHUB_OUTPUT
        echo "TESTS_PASSED=$($results.PassedCount)" >> $env:GITHUB_OUTPUT
        echo "TESTS_FAILED=$($results.FailedCount)" >> $env:GITHUB_OUTPUT

        if ($results.FailedCount -gt 0) {
          Write-Host "::error::$($results.FailedCount) test(s) failed"
          exit 1
        }

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: ./test-results.xml
        if-no-files-found: warn
        retention-days: 14

    - name: Upload test diagnostics
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-diagnostics
        path: ./.ci-artifacts/legacy/test/*
        if-no-files-found: warn
        retention-days: 7

    - name: Test job summary
      if: always()
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $testsRun = '${{ steps.pester.outputs.TESTS_RUN }}'
        $testsPassed = '${{ steps.pester.outputs.TESTS_PASSED }}'
        $testsFailed = '${{ steps.pester.outputs.TESTS_FAILED }}'

        $summaryLines = @(
          '',
          '## Job Summary',
          "* Tests run: $testsRun",
          "* Tests passed: $testsPassed",
          "* Tests failed: $testsFailed",
          '* Diagnostics: .ci-artifacts/legacy/test'
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY

  #############################################
  # Build Executable
  #############################################
  build:
    name: Build Executable
    runs-on: windows-2022
    timeout-minutes: 45
    needs: [code-review, test]
    if: |
      always() &&
      (needs.code-review.result == 'success' || needs.code-review.result == 'skipped') &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    env:
      CI_LOG_ROOT: .\.ci-artifacts\legacy\build
    outputs:
      version: ${{ steps.version.outputs.VERSION }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v6

    - name: Record CI context & prepare diagnostics
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $context = @{
          Workflow = "${{ github.workflow }}"
          Job = "${{ github.job }}"
          Event = "${{ github.event_name }}"
          Runner = "${{ runner.name }}"
          Ref = "${{ github.ref }}"
          SHA = "${{ github.sha }}"
        }

        $summaryLines = @(
          '## CI Context',
          "* Workflow: $($context.Workflow)",
          "* Job: $($context.Job)",
          "* Event: $($context.Event)",
          "* Runner: $($context.Runner)",
          "* Ref: $($context.Ref)",
          "* SHA: $($context.SHA)"
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY
        New-Item -ItemType Directory -Path $env:CI_LOG_ROOT -Force | Out-Null

    - name: Get version
      id: version
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $generalLog = Join-Path $diagRoot 'build-general.log'

        if ("${{ github.event.inputs.version }}" -ne "") {
          $version = "${{ github.event.inputs.version }}"
        } else {
          # Read from build.ps1
          $buildContent = Get-Content ".\build.ps1" -Raw
          if ($buildContent -match '\$Version\s*=\s*"([^"]+)"') {
            $version = $Matches[1]
          } else {
            $version = "${{ env.DEFAULT_VERSION }}"
          }
        }
        echo "VERSION=$version" >> $env:GITHUB_OUTPUT
        Write-Host "Version: $version" -ForegroundColor Cyan
        "Version: $version" | Add-Content -Path $generalLog

    - name: Install PS2EXE
      shell: powershell
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        .\build\Install-ModuleWithRetry.ps1 -ModuleName ps2exe -AllowClobber

    - name: Build executable
      id: build_exe
      shell: powershell
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $buildLog = Join-Path $diagRoot 'build-exe.log'

        $version = "${{ steps.version.outputs.VERSION }}"

        Import-Module ps2exe -Force -ErrorAction Stop

        $buildStart = Get-Date

        $buildParams = @{
          InputFile = ".\Scripts\WsusManagementGui.ps1"
          OutputFile = ".\WsusManager.exe"
          NoConsole = $true
          RequireAdmin = $true
          Title = "WSUS Manager"
          Description = "WSUS Manager - GUI for Windows Server Update Services"
          Company = "GA-ASI"
          Product = "WSUS Manager"
          Copyright = "Tony Tran, ISSO - GA-ASI"
          Version = "$version.0"
          STA = $true
          x64 = $true
        }

        if (Test-Path ".\wsus-icon.ico") {
          $buildParams.IconFile = ".\wsus-icon.ico"
        }

        Invoke-PS2EXE @buildParams

        $buildDuration = [math]::Round(((Get-Date) - $buildStart).TotalSeconds, 2)
        echo "BUILD_DURATION=$buildDuration" >> $env:GITHUB_OUTPUT

        if (Test-Path ".\WsusManager.exe") {
          Write-Host "Build successful in ${buildDuration}s!" -ForegroundColor Green
          "Build successful in ${buildDuration}s!" | Add-Content -Path $buildLog
        } else {
          Write-Host "Build failed" -ForegroundColor Red
          "Build failed" | Add-Content -Path $buildLog
          exit 1
        }

    - name: Run EXE Validation Tests
      id: exe-validation
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $exeLog = Join-Path $diagRoot 'exe-validation.log'
        $exeJson = Join-Path $diagRoot 'exe-validation.json'

        Write-Host "=== Running EXE Validation Tests ===" -ForegroundColor Cyan
        "=== Running EXE Validation Tests ===" | Add-Content -Path $exeLog

        # Install Pester if not present
        if (-not (Get-Module -ListAvailable -Name Pester | Where-Object { $_.Version -ge '5.0.0' })) {
          .\build\Install-ModuleWithRetry.ps1 -ModuleName Pester -MinimumVersion 5.0.0
        }
        Import-Module Pester -MinimumVersion 5.0.0 -Force

        $config = New-PesterConfiguration
        $config.Run.Path = "./Tests/ExeValidation.Tests.ps1"
        $config.Run.Exit = $false
        $config.Run.PassThru = $true
        $config.Output.Verbosity = 'Detailed'

        $results = Invoke-Pester -Configuration $config
        if (-not $results) {
          Write-Host "::error::Invoke-Pester did not return results for EXE validation"
          exit 1
        }

        Write-Host "`n=== EXE Validation Summary ===" -ForegroundColor Cyan
        Write-Host "Passed: $($results.PassedCount)" -ForegroundColor Green
        Write-Host "Failed: $($results.FailedCount)" -ForegroundColor $(if ($results.FailedCount -gt 0) { 'Red' } else { 'Green' })
        Write-Host "Skipped: $($results.SkippedCount)" -ForegroundColor Yellow
        @(
          "Passed: $($results.PassedCount)",
          "Failed: $($results.FailedCount)",
          "Skipped: $($results.SkippedCount)"
        ) | Add-Content -Path $exeLog
        (
          [pscustomobject]@{
            Passed = $results.PassedCount
            Failed = $results.FailedCount
            Skipped = $results.SkippedCount
          }
        ) | ConvertTo-Json -Depth 3 | Out-File -FilePath $exeJson -Encoding utf8

        echo "EXE_VALIDATION_PASSED=$($results.PassedCount)" >> $env:GITHUB_OUTPUT
        echo "EXE_VALIDATION_FAILED=$($results.FailedCount)" >> $env:GITHUB_OUTPUT
        echo "EXE_VALIDATION_SKIPPED=$($results.SkippedCount)" >> $env:GITHUB_OUTPUT

        if ($results.FailedCount -gt 0) {
          Write-Host "::warning::$($results.FailedCount) EXE validation test(s) failed"
        }

    - name: Create distribution package
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $packagingLog = Join-Path $diagRoot 'packaging.log'

        $version = "${{ steps.version.outputs.VERSION }}"
        $packageName = "WsusManager-v$version"
        $distDir = ".\dist"
        $packageDir = "$distDir\staging"

        # Clean and create dist folder
        if (Test-Path $distDir) { Remove-Item -Path $distDir -Recurse -Force }
        New-Item -ItemType Directory -Path $packageDir -Force | Out-Null

        # Copy main executable
        Copy-Item ".\WsusManager.exe" -Destination $packageDir

        # Copy required folders (Scripts and Modules are REQUIRED for the EXE to work)
        if (Test-Path ".\Scripts") {
          Copy-Item ".\Scripts" -Destination "$packageDir\Scripts" -Recurse
          Write-Host "Copied Scripts folder" -ForegroundColor Green
          "Copied Scripts folder" | Add-Content -Path $packagingLog
        } else {
          Write-Host "::error::Scripts folder not found - EXE will not work!"
          "Scripts folder missing" | Add-Content -Path $packagingLog
          exit 1
        }

        if (Test-Path ".\Modules") {
          Copy-Item ".\Modules" -Destination "$packageDir\Modules" -Recurse
          Write-Host "Copied Modules folder" -ForegroundColor Green
          "Copied Modules folder" | Add-Content -Path $packagingLog
        } else {
          Write-Host "::error::Modules folder not found - EXE will not work!"
          "Modules folder missing" | Add-Content -Path $packagingLog
          exit 1
        }

        # Copy optional files/folders
        if (Test-Path ".\DomainController") {
          Copy-Item ".\DomainController" -Destination "$packageDir\DomainController" -Recurse
          Write-Host "Copied DomainController folder" -ForegroundColor Green
          "Copied DomainController folder" | Add-Content -Path $packagingLog
        }
        foreach ($optional in @('.\wsus-icon.ico', '.\general_atomics_logo_small.ico', '.\general_atomics_logo_big.ico', '.\README.md', '.\QUICK-START.txt')) {
          if (Test-Path $optional) {
            Copy-Item $optional -Destination $packageDir
            "Copied $optional" | Add-Content -Path $packagingLog
          }
        }

        # List contents for verification
        Write-Host "`nPackage contents:" -ForegroundColor Cyan
        Get-ChildItem -Path $packageDir -Recurse | ForEach-Object {
          $relativePath = $_.FullName.Replace((Get-Item $packageDir).FullName, "")
          Write-Host "  $relativePath"
          "  $relativePath" | Add-Content -Path $packagingLog
        }

        # Create single zip with everything needed to run
        Compress-Archive -Path "$packageDir\*" -DestinationPath "$distDir\$packageName.zip" -Force
        "Compressed $packageDir to $distDir\$packageName.zip" | Add-Content -Path $packagingLog

        # Remove staging directory - only keep the zip
        Remove-Item -Path $packageDir -Recurse -Force

        Write-Host "`nFinal artifact:" -ForegroundColor Cyan
        Get-ChildItem -Path $distDir -File | ForEach-Object {
          Write-Host "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)"
          "  $($_.Name) ($([math]::Round($_.Length / 1MB, 2)) MB)" | Add-Content -Path $packagingLog
        }

    - name: Prepare artifact for direct download
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $diagRoot = $env:CI_LOG_ROOT
        New-Item -ItemType Directory -Path $diagRoot -Force | Out-Null
        $artifactLog = Join-Path $diagRoot 'artifact-prep.log'

        $version = "${{ steps.version.outputs.VERSION }}"
        $distDir = ".\dist"
        $stagingFinal = "$distDir\staging-final"

        # Create final staging with extracted contents (not the zip)
        # This prevents the "zip within zip" issue when downloading artifacts
        New-Item -ItemType Directory -Path $stagingFinal -Force | Out-Null

        # Extract our zip to the staging-final folder so artifact download works directly
        $zipPath = Get-ChildItem -Path $distDir -Filter "*.zip" | Select-Object -First 1
        if ($zipPath) {
          Expand-Archive -Path $zipPath.FullName -DestinationPath $stagingFinal -Force
          Write-Host "Extracted $($zipPath.Name) for direct artifact download" -ForegroundColor Green
          "Extracted $($zipPath.Name) to $stagingFinal" | Add-Content -Path $artifactLog

          # Show final contents
          Write-Host "`nArtifact contents:" -ForegroundColor Cyan
          Get-ChildItem -Path $stagingFinal -Recurse | ForEach-Object {
            $relativePath = $_.FullName.Replace((Get-Item $stagingFinal).FullName, "")
            Write-Host "  $relativePath"
          }
        }

    - name: Upload build artifact (extracted for direct download)
      uses: actions/upload-artifact@v4
      with:
        name: WsusManager-v${{ steps.version.outputs.VERSION }}
        path: ./dist/staging-final/*
        retention-days: 30

    - name: Upload release artifact (zip for GitHub releases)
      uses: actions/upload-artifact@v4
      with:
        name: WsusManager-v${{ steps.version.outputs.VERSION }}-release
        path: ./dist/*.zip
        retention-days: 30

    - name: Upload build diagnostics
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-diagnostics
        path: ./.ci-artifacts/legacy/build/*
        if-no-files-found: warn
        retention-days: 7

    - name: Build job summary
      if: always()
      shell: pwsh
      run: |
        Set-StrictMode -Version Latest
        $ErrorActionPreference = 'Stop'

        $version = '${{ steps.version.outputs.VERSION }}'
        $buildDuration = '${{ steps.build_exe.outputs.BUILD_DURATION }}'
        $exePassed = '${{ steps.exe-validation.outputs.EXE_VALIDATION_PASSED }}'
        $exeFailed = '${{ steps.exe-validation.outputs.EXE_VALIDATION_FAILED }}'
        $exeSkipped = '${{ steps.exe-validation.outputs.EXE_VALIDATION_SKIPPED }}'

        $summaryLines = @(
          '',
          '## Job Summary',
          "* Version: $version",
          "* Build duration: $buildDuration s",
          "* EXE validation (passed/failed/skipped): $exePassed/$exeFailed/$exeSkipped",
          '* Diagnostics: .ci-artifacts/legacy/build'
        )

        $summaryLines | Add-Content -Path $env:GITHUB_STEP_SUMMARY

  #############################################
  # Create Release
  #############################################
  release:
    name: Create Release
    needs: build
    runs-on: ubuntu-latest
    if: github.event.inputs.create_release == 'true'
    permissions:
      contents: write

    steps:
    - name: Download release artifact
      uses: actions/download-artifact@v4
      with:
        name: WsusManager-v${{ needs.build.outputs.version }}-release
        path: ./dist

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.build.outputs.version }}
        name: WSUS Manager v${{ needs.build.outputs.version }}
        draft: false
        prerelease: false
        files: ./dist/*.zip
        body: |
          ## WSUS Manager v${{ needs.build.outputs.version }}

          ### What's New

          **Deep Cleanup Fix** - Now performs full 6-step database maintenance:
          1. WSUS built-in cleanup (decline superseded, remove obsolete)
          2. Remove supersession records for declined updates
          3. Remove supersession records for superseded updates (batched)
          4. Delete declined updates from database via `spDeleteUpdate`
          5. Rebuild/reorganize fragmented indexes + update statistics
          6. Shrink database to reclaim disk space

          **Unified Diagnostics** - Combined Health Check + Repair into single operation with automatic fixes

          **Security Definitions** - Definition Updates (antivirus signatures) now auto-approved

          **Reset Content Button** - Fix "content downloading" status after air-gap database import

          ### Downloads
          | Package | Description |
          |---------|-------------|
          | `WsusManager-v${{ needs.build.outputs.version }}.zip` | Complete distribution package |

          ### Requirements
          - Windows Server 2016, 2019, 2022, or 2025
          - Administrator privileges
          - .NET Framework 4.7.2+

          ### Installation
          1. Extract the zip file
          2. Keep `Scripts/` and `Modules/` folders with the EXE
          3. Run `WsusManager.exe` as Administrator

          ### Full Changelog
          See [CHANGELOG](https://github.com/anthonyscry/GA-WsusManager/wiki/Changelog) for details.
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
